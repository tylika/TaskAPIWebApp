models
Comment.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class Comment
{
    public int Id { get; set; }

    public string Content { get; set; } = null!;

    public int UserId { get; set; }

    public int? TaskId { get; set; }

    public int? TaskSubmissionId { get; set; }

    public DateTime? CreatedAt { get; set; }

    public virtual Task? Task { get; set; }

    public virtual TaskSubmission? TaskSubmission { get; set; }

    public virtual User User { get; set; } = null!;
}

//
CommentInputDto.cs
//
using System.ComponentModel.DataAnnotations;

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class CommentInputDto
    {
        [Required(ErrorMessage = "Текст коментаря є обов'язковим.")]
        public string Content { get; set; }

        [Required(ErrorMessage = "ID Користувача є обов'язковим.")]
        public int UserId { get; set; }

        public int? TaskId { get; set; } // ID Завдання, до якого коментар

        public int? TaskSubmissionId { get; set; } // ID Подання завдання, до якого коментар
    }
}
//
GroupMember.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class GroupMember
{
    public int UserId { get; set; }

    public int TaskGroupId { get; set; }

    public string Role { get; set; } = null!;

    public DateTime? JoinedAt { get; set; }

    public virtual TaskGroup TaskGroup { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}

//
GroupMemberInputRoleDto.cs
//
using System.ComponentModel.DataAnnotations;

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class GroupMemberInputDto
    {
        [Required(ErrorMessage = "ID Користувача є обов'язковим.")]
        public int UserId { get; set; }

        [Required(ErrorMessage = "ID Групи завдань є обов'язковим.")]
        public int TaskGroupId { get; set; }

        [Required(ErrorMessage = "Роль є обов'язковою.")]
        [StringLength(50, ErrorMessage = "Роль не може перевищувати 50 символів.")]
        public string Role { get; set; } // Наприклад, "Member", "Admin", "Viewer"
    }
}
//
GroupMemberUpdateRoleDto.cs
//
using System.ComponentModel.DataAnnotations;

public class GroupMemberUpdateRoleDto
{
    [Required(ErrorMessage = "Роль є обов'язковою.")]
    [StringLength(50, ErrorMessage = "Роль не може перевищувати 50 символів.")]
    public string Role { get; set; }
}
//
Task.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class Task
{
    public int Id { get; set; }

    public string Description { get; set; } = null!;

    public string Status { get; set; } = null!;

    public int UserId { get; set; }

    public int? TaskGroupId { get; set; }

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual ICollection<TaskAttachment> TaskAttachments { get; set; } = new List<TaskAttachment>();

    public virtual TaskGroup? TaskGroup { get; set; }

    public virtual ICollection<TaskSubmission> TaskSubmissions { get; set; } = new List<TaskSubmission>();

    public virtual User User { get; set; } = null!;
}

//
TaskAttachment.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class TaskAttachment
{
    public int Id { get; set; }

    public int TaskId { get; set; }

    public string FilePath { get; set; } = null!;

    public DateTime? UploadedAt { get; set; }

    public virtual Task Task { get; set; } = null!;
}

//
TaskAttachmentInputDto.cs
//
using System.ComponentModel.DataAnnotations;
// Якщо будемо реалізовувати завантаження файлів, тут може знадобитися IFormFile,
// але для поточного контролера, який приймає FilePath, DTO буде простим.
// Для реального завантаження, DTO для POST міг би бути іншим,
// наприклад, містити TaskId та IFormFile.

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class TaskAttachmentInputDto
    {
        [Required(ErrorMessage = "ID Завдання є обов'язковим.")]
        public int TaskId { get; set; }

        // Це поле буде заповнюватися на сервері після завантаження файлу.
        // Для поточного контролера, який приймає FilePath, залишимо його тут.
        // В реальному сценарії з IFormFile, це поле б не надходило від клієнта.
        [Required(ErrorMessage = "Шлях до файлу є обов'язковим (для поточної імплементації).")]
        [StringLength(1000, ErrorMessage = "Шлях до файлу не може перевищувати 1000 символів.")]
        public string FilePath { get; set; }
    }

    public class TaskAttachmentUpdateDto // DTO для оновлення, якщо потрібно
    {
        // Зазвичай оновлювати FilePath для існуючого вкладення може бути небажано,
        // можливо, краще видалити старе і додати нове.
        // Але якщо логіка дозволяє, можна додати поля для оновлення.
        // Наприклад, можна було б оновити опис файлу, якщо б таке поле було.
        // Для поточного контролера, він приймає весь об'єкт TaskAttachment.
        [Required]
        public string FilePath { get; set; }
    }
}
//
TaskGroup.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class TaskGroup
{
    public int Id { get; set; }

    public string Name { get; set; } = null!;

    public int UserId { get; set; }

    public virtual ICollection<GroupMember> GroupMembers { get; set; } = new List<GroupMember>();

    public virtual ICollection<Task> Tasks { get; set; } = new List<Task>();

    public virtual User User { get; set; } = null!;
}

//
TaskGroupInputDto.cs
//
using System.ComponentModel.DataAnnotations;

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class TaskGroupInputDto
    {
        [Required(ErrorMessage = "Назва групи є обов'язковою.")]
        [StringLength(255, ErrorMessage = "Назва групи не може перевищувати 255 символів.")]
        public string Name { get; set; }

        [Required(ErrorMessage = "ID Власника групи є обов'язковим.")]
        public int UserId { get; set; }
    }
}
//
TaskInputDto.cs
//
using System.ComponentModel.DataAnnotations;

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class TaskInputDto
    {
        [Required(ErrorMessage = "Опис є обов'язковим.")]
        [StringLength(1000, ErrorMessage = "Опис не може перевищувати 1000 символів.")]
        public string Description { get; set; }

        [Required(ErrorMessage = "Статус є обов'язковим.")]
        [StringLength(50, ErrorMessage = "Статус не може перевищувати 50 символів.")]
        public string Status { get; set; }

        [Required(ErrorMessage = "ID Користувача є обов'язковим.")]
        public int UserId { get; set; }

        public int? TaskGroupId { get; set; }
    }
}
//
TaskSubmission.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class TaskSubmission
{
    public int Id { get; set; }

    public int TaskId { get; set; }

    public int UserId { get; set; }

    public string Submission { get; set; } = null!;

    public string Status { get; set; } = null!;

    public int? Score { get; set; }

    public DateTime? SubmittedAt { get; set; }

    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();

    public virtual Task Task { get; set; } = null!;

    public virtual User User { get; set; } = null!;
}

//
TaskSubmissionInputDto.cs
//
using System.ComponentModel.DataAnnotations;

namespace TaskAPIWebApp.Models // Або TaskAPIWebApp.Models.Dtos
{
    public class TaskSubmissionInputDto
    {
        [Required(ErrorMessage = "ID Завдання є обов'язковим.")]
        public int TaskId { get; set; }

        [Required(ErrorMessage = "ID Користувача є обов'язковим.")]
        public int UserId { get; set; }

        [Required(ErrorMessage = "Текст подання є обов'язковим.")]
        public string Submission { get; set; } // Текст відповіді або посилання

        [Required(ErrorMessage = "Статус подання є обов'язковим.")]
        [StringLength(50)]
        public string Status { get; set; }

        [Range(0, 100, ErrorMessage = "Оцінка має бути в межах від 0 до 100.")]
        public int? Score { get; set; }
    }

    // DTO для оновлення, якщо потрібно оновлювати тільки певні поля, наприклад, статус та оцінку
    public class TaskSubmissionUpdateDto
    {
        [Required(ErrorMessage = "Статус подання є обов'язковим.")]
        [StringLength(50)]
        public string Status { get; set; }

        [Range(0, 100, ErrorMessage = "Оцінка має бути в межах від 0 до 100.")]
        public int? Score { get; set; }

        // Можливо, оновлення самого тексту подання
        // public string? Submission { get; set; } 
    }
}
//
User.cs
//
using System;
using System.Collections.Generic;

namespace TaskAPIWebApp.Models;

public partial class User
{
    public int Id { get; set; }
    public string Username { get; set; } = null!; // Залишаємо ім'я як основний ідентифікатор

    // Навігаційні властивості залишаються, оскільки вони потрібні для зв'язків EF Core
    public virtual ICollection<Comment> Comments { get; set; } = new List<Comment>();
    public virtual ICollection<GroupMember> GroupMembers { get; set; } = new List<GroupMember>();
    public virtual ICollection<TaskGroup> TaskGroups { get; set; } = new List<TaskGroup>(); // Де користувач є власником групи
    public virtual ICollection<TaskSubmission> TaskSubmissions { get; set; } = new List<TaskSubmission>();
    public virtual ICollection<Task> Tasks { get; set; } = new List<Task>(); // Де користувач є виконавцем/створювачем завдання
}
//
UserCreationDto.cs
//
using System.ComponentModel.DataAnnotations;

public class UserCreationDto
{
    [Required(ErrorMessage = "Ім'я користувача є обов'язковим.")]
    [StringLength(255)]
    public string Username { get; set; }
}
//
Controllers
CommentsController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Для Comment та CommentInputDto
using System.Threading.Tasks; // Для Task
using System.Linq; // Для .Any()

namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Коментарі")]
    [Produces("application/json")]
    public class CommentsController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public CommentsController(TaskManagementApiContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<Comment>>> GetComments(int? taskSubmissionId, int? taskId)
        {
            var query = _context.Comments.AsQueryable();
            if (taskSubmissionId.HasValue)
            {
                query = query.Where(c => c.TaskSubmissionId == taskSubmissionId.Value);
            }
            if (taskId.HasValue)
            {
                query = query.Where(c => c.TaskId == taskId.Value);
            }
            // Для кращого відображення можна додати .Include(c => c.User)
            return await query.Include(c => c.User)
                              .OrderByDescending(c => c.CreatedAt) // Показуємо новіші спочатку
                              .ToListAsync();
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<Comment>> GetComment(int id)
        {
            // Для кращого відображення можна додати .Include(c => c.User)
            var comment = await _context.Comments
                                        .Include(c => c.User)
                                        .FirstOrDefaultAsync(c => c.Id == id);
            if (comment == null)
            {
                return NotFound(new { message = $"Коментар з ID {id} не знайдено." });
            }
            return comment;
        }

        [HttpPost]
        public async Task<ActionResult<Comment>> CreateComment(CommentInputDto commentDto) // Використовуємо DTO
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (commentDto.TaskId.HasValue && commentDto.TaskSubmissionId.HasValue)
            {
                return BadRequest(new { message = "Коментар не може бути пов’язаний одночасно з завданням і поданням." });
            }
            if (!commentDto.TaskId.HasValue && !commentDto.TaskSubmissionId.HasValue)
            {
                return BadRequest(new { message = "Коментар має бути пов’язаний із завданням або поданням." });
            }

            // Перевірка існування користувача
            if (!await _context.Users.AnyAsync(u => u.Id == commentDto.UserId))
            {
                return BadRequest(new { message = $"Користувач з ID {commentDto.UserId} не існує." });
            }

            TaskAPIWebApp.Models.Task? associatedTask = null; // Для перевірки членства в групі

            if (commentDto.TaskId.HasValue)
            {
                associatedTask = await _context.Tasks.FindAsync(commentDto.TaskId.Value);
                if (associatedTask == null)
                {
                    return BadRequest(new { message = $"Завдання із ID {commentDto.TaskId.Value} не існує." });
                }
            }
            else if (commentDto.TaskSubmissionId.HasValue) // else if, бо тільки один з них може бути
            {
                var submission = await _context.TaskSubmissions.FindAsync(commentDto.TaskSubmissionId.Value);
                if (submission == null)
                {
                    return BadRequest(new { message = $"Подання із ID {commentDto.TaskSubmissionId.Value} не існує." });
                }
                associatedTask = await _context.Tasks.FindAsync(submission.TaskId);
                if (associatedTask == null)
                {
                    // Ця помилка малоймовірна, якщо submission.TaskId валідний, але для повноти
                    return BadRequest(new { message = "Завдання, пов’язане з поданням, не знайдено." });
                }
            }

            // Перевірка, чи користувач є членом групи, пов’язаної з завданням (якщо завдання належить групі)
            if (associatedTask != null && associatedTask.TaskGroupId.HasValue)
            {
                if (!await _context.GroupMembers.AnyAsync(gm => gm.UserId == commentDto.UserId && gm.TaskGroupId == associatedTask.TaskGroupId.Value))
                {
                    return BadRequest(new { message = "Користувач не є членом групи, пов’язаної з цим завданням/поданням." });
                }
            }

            var comment = new Comment
            {
                Content = commentDto.Content,
                UserId = commentDto.UserId,
                TaskId = commentDto.TaskId,
                TaskSubmissionId = commentDto.TaskSubmissionId,
                CreatedAt = DateTime.UtcNow // Встановлюємо тут
            };

            _context.Comments.Add(comment);
            await _context.SaveChangesAsync();
            // Повертаємо повний об'єкт Comment, включаючи User для відображення
            var createdComment = await _context.Comments
                                              .Include(c => c.User)
                                              .FirstOrDefaultAsync(c => c.Id == comment.Id);
            return CreatedAtAction(nameof(GetComment), new { id = comment.Id }, createdComment);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateComment(int id, CommentInputDto commentDto) // Використовуємо DTO
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var commentToUpdate = await _context.Comments.FindAsync(id);
            if (commentToUpdate == null)
            {
                return NotFound(new { message = $"Коментар з ID {id} не знайдено." });
            }

            // Основні перевірки з CreateComment можна повторити, якщо логіка дозволяє змінювати UserId або прив'язку
            // Зазвичай UserId коментаря не змінюють, але Content - так.
            // Також не дозволяємо змінювати TaskId/TaskSubmissionId після створення.
            if (commentToUpdate.UserId != commentDto.UserId)
            {
                // Якщо зміна UserId дозволена, потрібні перевірки існування нового користувача та його прав
                return BadRequest(new { message = "Зміна автора коментаря не дозволена." });
            }
            if (commentToUpdate.TaskId != commentDto.TaskId || commentToUpdate.TaskSubmissionId != commentDto.TaskSubmissionId)
            {
                return BadRequest(new { message = "Зміна прив'язки коментаря (до завдання/подання) не дозволена." });
            }
            // Перевірка, що нові TaskId/TaskSubmissionId (якщо їх дозволено змінювати) валідні, як у Create

            commentToUpdate.Content = commentDto.Content;
            // CreatedAt не оновлюємо, але можна додати поле UpdatedAt

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await CommentExists(id)) // Додав await
                {
                    return NotFound();
                }
                throw;
            }
            return NoContent();
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteComment(int id)
        {
            var comment = await _context.Comments.FindAsync(id);
            if (comment == null)
            {
                return NotFound(new { message = $"Коментар з ID {id} не знайдено." });
            }

            _context.Comments.Remove(comment);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> CommentExists(int id) // Зробив асинхронним
        {
            return await _context.Comments.AnyAsync(e => e.Id == id);
        }
    }
}
//
GroupMembersController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Для GroupMember та GroupMemberInputDto
using System.Threading.Tasks;
using System.Linq;
using System.Collections.Generic; // Для IEnumerable

namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Члени груп")]
    [Produces("application/json")]
    public class GroupMembersController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public GroupMembersController(TaskManagementApiContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Отримати список усіх членів груп
        /// </summary>
        /// <param name="taskGroupId">Фільтр за ID групи (опціонально)</param>
        /// <returns>Список членів груп з іменами користувачів та назвами груп</returns>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<object>>> GetGroupMembers(int? taskGroupId)
        {
            var query = _context.GroupMembers
                .Include(gm => gm.User) // Включаємо дані користувача
                .Include(gm => gm.TaskGroup) // Включаємо дані групи
                .Select(gm => new
                {
                    gm.UserId,
                    Username = gm.User.Username, // Додаємо ім'я користувача
                    gm.TaskGroupId,
                    TaskGroupName = gm.TaskGroup.Name, // Додаємо назву групи
                    gm.Role,
                    gm.JoinedAt
                });

            if (taskGroupId.HasValue)
            {
                query = query.Where(gm => gm.TaskGroupId == taskGroupId.Value);
            }
            return await query.OrderBy(gm => gm.TaskGroupName).ThenBy(gm => gm.Username).ToListAsync();
        }

        /// <summary>
        /// Отримати члена групи за складеним ключем (ID користувача та ID групи)
        /// </summary>
        /// <param name="userId">Ідентифікатор користувача</param>
        /// <param name="taskGroupId">Ідентифікатор групи завдань</param>
        /// <returns>Член групи з деталями</returns>
        [HttpGet("user/{userId}/group/{taskGroupId}")]
        public async Task<ActionResult<object>> GetGroupMember(int userId, int taskGroupId)
        {
            var groupMember = await _context.GroupMembers
                .Include(gm => gm.User)
                .Include(gm => gm.TaskGroup)
                .Where(gm => gm.UserId == userId && gm.TaskGroupId == taskGroupId)
                .Select(gm => new
                {
                    gm.UserId,
                    Username = gm.User.Username,
                    gm.TaskGroupId,
                    TaskGroupName = gm.TaskGroup.Name,
                    gm.Role,
                    gm.JoinedAt
                })
                .FirstOrDefaultAsync();

            if (groupMember == null)
            {
                return NotFound(new { message = $"Членство для користувача ID {userId} у групі ID {taskGroupId} не знайдено." });
            }
            return groupMember;
        }

        /// <summary>
        /// Додати нового члена до групи
        /// </summary>
        /// <param name="dto">Дані нового члена групи</param>
        /// <returns>Створений член групи</returns>
        [HttpPost]
        public async Task<ActionResult<GroupMember>> CreateGroupMember(GroupMemberInputDto dto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (await _context.GroupMembers.AnyAsync(gm => gm.UserId == dto.UserId && gm.TaskGroupId == dto.TaskGroupId))
            {
                return BadRequest(new { message = "Користувач уже є членом цієї групи." });
            }

            if (!await _context.Users.AnyAsync(u => u.Id == dto.UserId))
            {
                return BadRequest(new { message = $"Користувач із ID {dto.UserId} не існує." });
            }
            if (!await _context.TaskGroups.AnyAsync(tg => tg.Id == dto.TaskGroupId))
            {
                return BadRequest(new { message = $"Група із ID {dto.TaskGroupId} не існує." });
            }

            var groupMember = new GroupMember
            {
                UserId = dto.UserId,
                TaskGroupId = dto.TaskGroupId,
                Role = dto.Role,
                JoinedAt = DateTime.UtcNow
            };

            _context.GroupMembers.Add(groupMember);
            await _context.SaveChangesAsync();

            // Повертаємо розширений об'єкт для відповідності GetGroupMember
            var createdMembershipDetails = await _context.GroupMembers
                .Include(gm => gm.User)
                .Include(gm => gm.TaskGroup)
                .Where(gm => gm.UserId == groupMember.UserId && gm.TaskGroupId == groupMember.TaskGroupId)
                .Select(gm => new
                {
                    gm.UserId,
                    Username = gm.User.Username,
                    gm.TaskGroupId,
                    TaskGroupName = gm.TaskGroup.Name,
                    gm.Role,
                    gm.JoinedAt
                })
                .FirstOrDefaultAsync();

            return CreatedAtAction(nameof(GetGroupMember), new { userId = groupMember.UserId, taskGroupId = groupMember.TaskGroupId }, createdMembershipDetails);
        }

        /// <summary>
        /// Оновити роль члена групи
        /// </summary>
        /// <param name="userId">Ідентифікатор користувача</param>
        /// <param name="taskGroupId">Ідентифікатор групи завдань</param>
        /// <param name="dto">Оновлені дані (тільки роль)</param>
        /// <returns>Статус операції</returns>
        [HttpPut("user/{userId}/group/{taskGroupId}")]
        public async Task<IActionResult> UpdateGroupMember(int userId, int taskGroupId, [FromBody] GroupMemberUpdateRoleDto dto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var groupMember = await _context.GroupMembers.FindAsync(userId, taskGroupId);
            if (groupMember == null)
            {
                return NotFound(new { message = "Членство не знайдено." });
            }

            // Перевірка: не дозволяємо змінювати роль єдиного адміністратора на іншу, якщо він єдиний
            if (groupMember.Role == "Адмін" && dto.Role != "Адмін")
            {
                var otherAdmins = await _context.GroupMembers
                    .CountAsync(gm => gm.TaskGroupId == taskGroupId && gm.Role == "Адмін" && gm.UserId != userId);
                if (otherAdmins == 0)
                {
                    return BadRequest(new { message = "Неможливо змінити роль єдиного адміністратора групи." });
                }
            }

            groupMember.Role = dto.Role;
            // JoinedAt не оновлюємо, UserId та TaskGroupId є частиною ключа і не змінюються тут

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await GroupMemberExists(userId, taskGroupId)) // Додав await
                {
                    return NotFound();
                }
                throw;
            }
            return NoContent();
        }

        [HttpDelete("user/{userId}/group/{taskGroupId}")]
        public async Task<IActionResult> DeleteGroupMember(int userId, int taskGroupId)
        {
            var groupMember = await _context.GroupMembers.FindAsync(userId, taskGroupId);
            if (groupMember == null)
            {
                return NotFound(new { message = "Членство не знайдено." });
            }

            if (groupMember.Role == "Адмін")
            {
                var otherAdmins = await _context.GroupMembers
                    .CountAsync(gm => gm.TaskGroupId == taskGroupId && gm.Role == "Адмін" && gm.UserId != userId);
                if (otherAdmins == 0)
                {
                    return BadRequest(new { message = "Неможливо видалити єдиного адміністратора групи." });
                }
            }

            _context.GroupMembers.Remove(groupMember);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> GroupMemberExists(int userId, int taskGroupId) // Зробив асинхронним
        {
            return await _context.GroupMembers.AnyAsync(e => e.UserId == userId && e.TaskGroupId == taskGroupId);
        }
    }

    
}
//
TaskAttachmentsController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Для TaskAttachment та DTO
using System.Threading.Tasks;
using System.Linq;
using System.Collections.Generic;

namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Вкладення завдань")]
    [Produces("application/json")]
    public class TaskAttachmentsController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;
        // Для реального завантаження файлів потрібен IWebHostEnvironment
        // private readonly IWebHostEnvironment _hostingEnvironment;

        public TaskAttachmentsController(TaskManagementApiContext context /*, IWebHostEnvironment hostingEnvironment */)
        {
            _context = context;
            // _hostingEnvironment = hostingEnvironment;
        }

        /// <summary>
        /// Отримати список усіх вкладень завдань
        /// </summary>
        /// <param name="taskId">Фільтр за ID завдання (опціонально)</param>
        /// <returns>Список вкладень завдань з деталями завдання</returns>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<object>>> GetTaskAttachments(int? taskId)
        {
            var query = _context.TaskAttachments
                .Include(ta => ta.Task) // Включаємо дані завдання
                .Select(ta => new
                {
                    ta.Id,
                    ta.TaskId,
                    TaskDescription = ta.Task != null ? ta.Task.Description : "N/A", // Додаємо опис завдання
                    ta.FilePath,
                    ta.UploadedAt
                });

            if (taskId.HasValue)
            {
                query = query.Where(ta => ta.TaskId == taskId.Value);
            }
            return await query.OrderByDescending(ta => ta.UploadedAt).ToListAsync();
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<object>> GetTaskAttachment(int id)
        {
            var taskAttachment = await _context.TaskAttachments
                .Include(ta => ta.Task)
                .Where(ta => ta.Id == id)
                .Select(ta => new
                {
                    ta.Id,
                    ta.TaskId,
                    TaskDescription = ta.Task != null ? ta.Task.Description : "N/A",
                    ta.FilePath,
                    ta.UploadedAt
                })
                .FirstOrDefaultAsync();

            if (taskAttachment == null)
            {
                return NotFound(new { message = $"Вкладення з ID {id} не знайдено." });
            }
            return taskAttachment;
        }

        /// <summary>
        /// Створити нове вкладення завдання (поточна версія приймає FilePath)
        /// </summary>
        /// <param name="dto">Дані нового вкладення</param>
        /// <returns>Створене вкладення</returns>
        [HttpPost]
        // Для реального завантаження: public async Task<ActionResult<TaskAttachment>> CreateTaskAttachment([FromForm] TaskAttachmentUploadDto dto)
        public async Task<ActionResult<TaskAttachment>> CreateTaskAttachment(TaskAttachmentInputDto dto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (dto.FilePath.Length > 1000) // Існуюча імітація
            {
                return BadRequest(new { message = "Шлях до файлу занадто довгий (імітація обмеження розміру)." });
            }

            if (!await _context.Tasks.AnyAsync(t => t.Id == dto.TaskId))
            {
                return BadRequest(new { message = $"Завдання із ID {dto.TaskId} не існує." });
            }

            // Тут мала б бути логіка завантаження файлу на сервер,
            // отримання реального шляху збереженого файлу і запис його в FilePath.
            // Наприклад:
            // string uniqueFileName = Guid.NewGuid().ToString() + "_" + dto.File.FileName;
            // string filePath = Path.Combine(_hostingEnvironment.WebRootPath, "uploads", uniqueFileName);
            // using (var fileStream = new FileStream(filePath, FileMode.Create))
            // {
            //     await dto.File.CopyToAsync(fileStream);
            // }
            // savedFilePath = "/uploads/" + uniqueFileName; // Шлях для доступу через веб

            var taskAttachment = new TaskAttachment
            {
                TaskId = dto.TaskId,
                FilePath = dto.FilePath, // Поки що беремо з DTO
                UploadedAt = DateTime.UtcNow
            };

            _context.TaskAttachments.Add(taskAttachment);
            await _context.SaveChangesAsync();

            // Повертаємо розширений об'єкт
            var createdAttachmentDetails = await _context.TaskAttachments
               .Include(ta => ta.Task)
               .Where(ta => ta.Id == taskAttachment.Id)
               .Select(ta => new {
                   ta.Id,
                   ta.TaskId,
                   TaskDescription = ta.Task.Description,
                   ta.FilePath,
                   ta.UploadedAt
               })
               .FirstOrDefaultAsync();


            return CreatedAtAction(nameof(GetTaskAttachment), new { id = taskAttachment.Id }, createdAttachmentDetails);
        }


        /// <summary>
        /// Оновити існуюче вкладення завдання (поточна версія приймає TaskAttachment)
        /// </summary>
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateTaskAttachment(int id, TaskAttachmentUpdateDto dto) // Можна використати DTO
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var taskAttachmentToUpdate = await _context.TaskAttachments.FindAsync(id);
            if (taskAttachmentToUpdate == null)
            {
                return NotFound(new { message = "Вкладення не знайдено." });
            }

            // Логіка оновлення. Зазвичай FilePath не змінюють напряму так просто.
            // Можливо, оновлюють метадані або замінюють файл (що є складнішою операцією).
            // Поки що, якщо DTO містить тільки FilePath:
            if (dto.FilePath.Length > 1000)
            {
                return BadRequest(new { message = "Новий шлях до файлу занадто довгий." });
            }
            taskAttachmentToUpdate.FilePath = dto.FilePath;
            // taskAttachmentToUpdate.TaskId не змінюємо, бо це прив'язка до іншої сутності.

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await TaskAttachmentExists(id)) // Додав await
                {
                    return NotFound();
                }
                throw;
            }
            return NoContent();
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteTaskAttachment(int id)
        {
            var taskAttachment = await _context.TaskAttachments.FindAsync(id);
            if (taskAttachment == null)
            {
                return NotFound(new { message = "Вкладення не знайдено." });
            }

            // Поточна логіка перевірки пов'язаних подань
            if (await _context.TaskSubmissions.AnyAsync(ts => ts.TaskId == taskAttachment.TaskId))
            {
                // Ця логіка може бути не зовсім коректною, якщо вкладення стосується конкретного завдання,
                // а не всіх подань до нього. Можливо, її варто переглянути або видалити.
                // return BadRequest(new { message = "Неможливо видалити вкладення: воно пов’язане з поданням." });
            }

            // TODO: Додати логіку фізичного видалення файлу з сервера/сховища
            // string filePathToDelete = Path.Combine(_hostingEnvironment.WebRootPath, taskAttachment.FilePath.TrimStart('/'));
            // if (System.IO.File.Exists(filePathToDelete))
            // {
            //     System.IO.File.Delete(filePathToDelete);
            // }

            _context.TaskAttachments.Remove(taskAttachment);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> TaskAttachmentExists(int id) // Зробив асинхронним
        {
            return await _context.TaskAttachments.AnyAsync(e => e.Id == id);
        }
    }
}
//
TaskGroupsController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Для TaskGroup та TaskGroupInputDto
using System.Threading.Tasks;
using System.Linq;
using System.Collections.Generic;

namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Групи завдань")]
    [Produces("application/json")]
    public class TaskGroupsController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public TaskGroupsController(TaskManagementApiContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Отримати список усіх груп завдань
        /// </summary>
        /// <param name="sortByDate">Сортувати за датою створення (asc/desc) - використовує Id як проксі</param>
        /// <returns>Список груп завдань з іменами власників</returns>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<object>>> GetTaskGroups(string sortByDate = "asc")
        {
            var query = _context.TaskGroups
                .Include(tg => tg.User) // Включаємо дані власника
                .Select(tg => new
                {
                    tg.Id,
                    tg.Name,
                    tg.UserId,
                    OwnerUsername = tg.User.Username // Додаємо ім'я власника
                    // Можна додати кількість завдань або членів, якщо потрібно
                    // TaskCount = tg.Tasks.Count(),
                    // MemberCount = tg.GroupMembers.Count()
                });

            if (sortByDate.ToLower() == "desc")
            {
                query = query.OrderByDescending(tg => tg.Id);
            }
            else
            {
                query = query.OrderBy(tg => tg.Id);
            }
            return await query.ToListAsync();
        }

        [HttpGet("lookup")]
        public async Task<ActionResult<IEnumerable<object>>> GetTaskGroupsLookup()
        {
            var taskGroups = await _context.TaskGroups
                .Select(tg => new { tg.Id, tg.Name })
                .OrderBy(tg => tg.Name)
                .ToListAsync();
            return Ok(taskGroups);
        }

        /// <summary>
        /// Отримати групу завдань за ID
        /// </summary>
        /// <param name="id">Ідентифікатор групи завдань</param>
        /// <returns>Група завдань з указаним ID та ім'ям власника</returns>
        [HttpGet("{id}")]
        public async Task<ActionResult<object>> GetTaskGroup(int id) // Змінив тип повернення для деталей
        {
            var taskGroup = await _context.TaskGroups
                .Include(tg => tg.User)
                .Where(tg => tg.Id == id)
                .Select(tg => new
                {
                    tg.Id,
                    tg.Name,
                    tg.UserId,
                    OwnerUsername = tg.User.Username
                })
                .FirstOrDefaultAsync();

            if (taskGroup == null)
            {
                return NotFound(new { message = $"Група завдань з ID {id} не знайдена." });
            }
            return taskGroup;
        }

        /// <summary>
        /// Створити нову групу завдань
        /// </summary>
        /// <param name="dto">Дані нової групи завдань</param>
        /// <returns>Створена група завдань з деталями</returns>
        [HttpPost]
        public async Task<ActionResult<object>> CreateTaskGroup(TaskGroupInputDto dto)
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            if (!await _context.Users.AnyAsync(u => u.Id == dto.UserId))
            {
                return BadRequest(new { message = $"Власник групи з ID {dto.UserId} не існує." });
            }

            var taskGroup = new TaskGroup
            {
                Name = dto.Name,
                UserId = dto.UserId
            };

            _context.TaskGroups.Add(taskGroup);
            await _context.SaveChangesAsync();

            // Повертаємо розширений об'єкт для відповідності GetTaskGroup
            var createdGroupDetails = await _context.TaskGroups
                .Include(tg => tg.User)
                .Where(tg => tg.Id == taskGroup.Id)
                .Select(tg => new { tg.Id, tg.Name, tg.UserId, OwnerUsername = tg.User.Username })
                .FirstOrDefaultAsync();

            return CreatedAtAction(nameof(GetTaskGroup), new { id = taskGroup.Id }, createdGroupDetails);
        }

        /// <summary>
        /// Оновити існуючу групу завдань
        /// </summary>
        /// <param name="id">Ідентифікатор групи завдань</param>
        /// <param name="dto">Оновлені дані групи завдань</param>
        /// <returns>Статус операції</returns>
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateTaskGroup(int id, TaskGroupInputDto dto) // Використовуємо DTO
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var taskGroupToUpdate = await _context.TaskGroups.FindAsync(id);
            if (taskGroupToUpdate == null)
            {
                return NotFound(new { message = "Група завдань не знайдена." });
            }

            if (!await _context.Users.AnyAsync(u => u.Id == dto.UserId))
            {
                return BadRequest(new { message = $"Новий власник групи з ID {dto.UserId} не існує." });
            }

            taskGroupToUpdate.Name = dto.Name;
            taskGroupToUpdate.UserId = dto.UserId; // Дозволяємо зміну власника

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await TaskGroupExists(id)) // Додав await
                {
                    return NotFound();
                }
                throw;
            }
            return NoContent();
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteTaskGroup(int id)
        {
            var taskGroup = await _context.TaskGroups.FindAsync(id);
            if (taskGroup == null)
            {
                return NotFound(new { message = "Група завдань не знайдена." });
            }

            if (await _context.Tasks.AnyAsync(t => t.TaskGroupId == id))
            {
                return BadRequest(new { message = "Неможливо видалити групу: у ній є активні завдання." });
            }

            // Додатково: що робити з членами групи (GroupMembers)?
            // За замовчуванням, якщо є зовнішній ключ з GroupMembers на TaskGroups,
            // і не налаштовано каскадне видалення, база даних може заборонити видалення.
            // Потрібно або видаляти членів групи спочатку, або налаштувати каскадне видалення.
            // Або, якщо логіка дозволяє, залишити цю перевірку.
            if (await _context.GroupMembers.AnyAsync(gm => gm.TaskGroupId == id))
            {
                // Можна або видалити членів, або повернути помилку
                // _context.GroupMembers.RemoveRange(_context.GroupMembers.Where(gm => gm.TaskGroupId == id));
                return BadRequest(new { message = "Неможливо видалити групу: у ній є зареєстровані члени. Спочатку видаліть членів." });
            }


            _context.TaskGroups.Remove(taskGroup);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> TaskGroupExists(int id) // Зробив асинхронним
        {
            return await _context.TaskGroups.AnyAsync(e => e.Id == id);
        }
    }
}
//
TasksController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Дозволяє використовувати TaskInputDto, якщо він там
// using TaskAPIWebApp.Models.Dtos; // Якщо TaskInputDto в підпапці Dtos
using System.Threading.Tasks; // Додано для Task
using System.Linq; // Додано для .Any()


namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Завдання")]
    [Produces("application/json")]
    public class TasksController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public TasksController(TaskManagementApiContext context)
        {
            _context = context;
        }

        [HttpGet]
        public async Task<ActionResult<IEnumerable<TaskAPIWebApp.Models.Task>>> GetTasks(string? status)
        {
            var query = _context.Tasks.AsQueryable();
            if (!string.IsNullOrEmpty(status))
            {
                query = query.Where(t => t.Status == status);
            }
            return await query.ToListAsync();
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<TaskAPIWebApp.Models.Task>> GetTask(int id)
        {
            var task = await _context.Tasks.FindAsync(id);
            if (task == null)
            {
                return NotFound(new { message = "Завдання не знайдено." });
            }
            return task;
        }

        [HttpPost]
        public async Task<ActionResult<TaskAPIWebApp.Models.Task>> CreateTask(TaskInputDto taskDto) // Змінено на TaskInputDto
        {
            // ModelState.IsValid перевіряється автоматично завдяки [ApiController]
            // але можна додати явну перевірку для ясності або кастомної логіки
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState); // Поверне стандартні помилки валідації DTO
            }

            if (!await UserExists(taskDto.UserId))
            {
                return BadRequest(new { message = "Користувач із вказаним ID не існує." });
            }

            if (taskDto.TaskGroupId.HasValue)
            {
                if (!await _context.TaskGroups.AnyAsync(tg => tg.Id == taskDto.TaskGroupId.Value)) // Використовуємо AnyAsync
                {
                    return BadRequest(new { message = "Група із таким ID не існує." });
                }
                if (!await _context.GroupMembers.AnyAsync(gm => gm.UserId == taskDto.UserId && gm.TaskGroupId == taskDto.TaskGroupId.Value)) // Використовуємо AnyAsync
                {
                    return BadRequest(new { message = "Користувач не є членом групи, до якої належить завдання." });
                }
            }

            var task = new TaskAPIWebApp.Models.Task
            {
                Description = taskDto.Description,
                Status = taskDto.Status,
                UserId = taskDto.UserId,
                TaskGroupId = taskDto.TaskGroupId
                // Інші властивості моделі Task, якщо є, будуть мати значення за замовчуванням або null
            };

            _context.Tasks.Add(task);
            await _context.SaveChangesAsync();
            // Повертаємо повний об'єкт Task, який включає згенерований Id та інші поля
            return CreatedAtAction(nameof(GetTask), new { id = task.Id }, task);
        }

        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateTask(int id, TaskInputDto taskDto) // Змінено на TaskInputDto
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var taskToUpdate = await _context.Tasks.FindAsync(id);

            if (taskToUpdate == null)
            {
                return NotFound(new { message = "Завдання не знайдено." });
            }

            // Перевірка існування користувача, якому призначається завдання
            if (!await UserExists(taskDto.UserId))
            {
                return BadRequest(new { message = "Користувач (UserId з тіла запиту) із вказаним ID не існує." });
            }

            // Перевірка групи та членства, якщо група вказана
            if (taskDto.TaskGroupId.HasValue)
            {
                if (!await _context.TaskGroups.AnyAsync(tg => tg.Id == taskDto.TaskGroupId.Value))
                {
                    return BadRequest(new { message = "Група із таким ID не існує." });
                }
                // Важливо: перевірка членства для нового UserId, якщо UserId змінюється
                if (!await _context.GroupMembers.AnyAsync(gm => gm.UserId == taskDto.UserId && gm.TaskGroupId == taskDto.TaskGroupId.Value))
                {
                    return BadRequest(new { message = "Користувач (UserId з тіла запиту) не є членом вказаної групи." });
                }
            }

            // Оновлюємо властивості існуючого завдання з DTO
            taskToUpdate.Description = taskDto.Description;
            taskToUpdate.Status = taskDto.Status;
            taskToUpdate.UserId = taskDto.UserId; // Дозволяємо зміну UserId
            taskToUpdate.TaskGroupId = taskDto.TaskGroupId; // Дозволяємо зміну TaskGroupId

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await TaskExists(id)) // Додано await
                {
                    return NotFound(new { message = "Завдання не знайдено під час спроби зберегти зміни (конфлікт)." });
                }
                else
                {
                    return Conflict(new { message = "Конфлікт оновлення: завдання було змінено іншим користувачем." });
                }
            }
            return NoContent();
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteTask(int id)
        {
            var task = await _context.Tasks.FindAsync(id);
            if (task == null)
            {
                return NotFound(new { message = "Завдання не знайдено." });
            }

            if (await _context.TaskSubmissions.AnyAsync(ts => ts.TaskId == id)) // Використовуємо AnyAsync
            {
                return BadRequest(new { message = "Неможливо видалити завдання: у нього є подання." });
            }

            _context.Tasks.Remove(task);
            await _context.SaveChangesAsync();
            return NoContent();
        }
        [HttpGet("lookup")]
        public async Task<ActionResult<IEnumerable<object>>> GetTasksLookup()
        {
            return await _context.Tasks
                .Select(t => new { t.Id, t.Description })
                .OrderBy(t => t.Description)
                .ToListAsync();
        }
        private async Task<bool> TaskExists(int id)
        {
            return await _context.Tasks.AnyAsync(e => e.Id == id);
        }

        private async Task<bool> UserExists(int userId)
        {
            return await _context.Users.AnyAsync(u => u.Id == userId);
        }
    }
}
//
TaskSubmissionsController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models; // Для TaskSubmission та DTO
using System.Threading.Tasks;
using System.Linq;
using System.Collections.Generic; // Для IEnumerable

namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Подання завдань")]
    [Produces("application/json")]
    public class TaskSubmissionsController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public TaskSubmissionsController(TaskManagementApiContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Отримати список усіх подань завдань
        /// </summary>
        /// <param name="userIdParam">Фільтр за ID користувача (опціонально) - змінив назву параметра</param>
        /// <param name="taskIdParam">Фільтр за ID завдання (опціонально) - додав новий параметр</param>
        /// <returns>Список подань завдань з деталями</returns>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<object>>> GetTaskSubmissions(
            [FromQuery(Name = "userId")] int? userIdParam,
            [FromQuery(Name = "taskId")] int? taskIdParam)
        {
            var query = _context.TaskSubmissions
                .Include(ts => ts.User)   // Включаємо дані користувача
                .Include(ts => ts.Task)   // Включаємо дані завдання
                .Select(ts => new
                {
                    ts.Id,
                    ts.TaskId,
                    TaskDescription = ts.Task.Description,
                    ts.UserId,
                    Username = ts.User.Username,
                    ts.Submission,
                    ts.Status,
                    ts.Score,
                    ts.SubmittedAt
                });

            if (userIdParam.HasValue)
            {
                query = query.Where(ts => ts.UserId == userIdParam.Value);
            }
            if (taskIdParam.HasValue)
            {
                query = query.Where(ts => ts.TaskId == taskIdParam.Value);
            }
            return await query.OrderByDescending(ts => ts.SubmittedAt).ToListAsync();
        }

        [HttpGet("lookup")]
        public async Task<ActionResult<IEnumerable<object>>> GetTaskSubmissionsLookup()
        {
            return await _context.TaskSubmissions
                .Include(ts => ts.User)
                .Include(ts => ts.Task)
                .OrderByDescending(ts => ts.SubmittedAt) // Новіші спочатку для вибору
                .Take(50) // Обмеження для lookup, щоб не завантажувати тисячі
                .Select(ts => new
                {
                    ts.Id,
                    DisplayText = $"Подання #{ts.Id} (Завд: {(ts.Task != null && ts.Task.Description != null ? ts.Task.Description.Substring(0, Math.Min(ts.Task.Description.Length, 20)) : "N/A")}... Користувач: {(ts.User != null ? ts.User.Username : "N/A")})"
                })
                .ToListAsync();
        }

        /// <summary>
        /// Отримати подання завдання за ID
        /// </summary>
        /// <param name="id">Ідентифікатор подання</param>
        /// <returns>Подання з указаним ID та деталями</returns>
        [HttpGet("{id}")]
        public async Task<ActionResult<object>> GetTaskSubmission(int id) // Змінив тип повернення
        {
            var taskSubmission = await _context.TaskSubmissions
                .Include(ts => ts.User)
                .Include(ts => ts.Task)
                .Where(ts => ts.Id == id)
                .Select(ts => new
                {
                    ts.Id,
                    ts.TaskId,
                    TaskDescription = ts.Task.Description,
                    ts.UserId,
                    Username = ts.User.Username,
                    ts.Submission,
                    ts.Status,
                    ts.Score,
                    ts.SubmittedAt
                })
                .FirstOrDefaultAsync();

            if (taskSubmission == null)
            {
                return NotFound(new { message = $"Подання з ID {id} не знайдено." });
            }
            return taskSubmission;
        }

        /// <summary>
        /// Створити нове подання завдання
        /// </summary>
        /// <param name="dto">Дані нового подання</param>
        /// <returns>Створене подання з деталями</returns>
        [HttpPost]
        public async Task<ActionResult<object>> CreateTaskSubmission(TaskSubmissionInputDto dto) // Використовуємо DTO
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var task = await _context.Tasks.FindAsync(dto.TaskId);
            if (task == null)
            {
                return BadRequest(new { message = $"Завдання із ID {dto.TaskId} не існує." });
            }
            if (!await _context.Users.AnyAsync(u => u.Id == dto.UserId)) // Перевірка існування користувача
            {
                return BadRequest(new { message = $"Користувач із ID {dto.UserId} не існує." });
            }


            if (task.TaskGroupId.HasValue)
            {
                if (!await _context.GroupMembers.AnyAsync(gm => gm.UserId == dto.UserId && gm.TaskGroupId == task.TaskGroupId.Value))
                {
                    return BadRequest(new { message = "Користувач не є членом групи, до якої належить завдання." });
                }
            }
            // Score валідується атрибутом Range в DTO

            var taskSubmission = new TaskSubmission
            {
                TaskId = dto.TaskId,
                UserId = dto.UserId,
                Submission = dto.Submission,
                Status = dto.Status,
                Score = dto.Score,
                SubmittedAt = DateTime.UtcNow
            };

            _context.TaskSubmissions.Add(taskSubmission);
            await _context.SaveChangesAsync();

            // Повертаємо розширений об'єкт
            var createdSubmissionDetails = await _context.TaskSubmissions
                .Include(ts => ts.User).Include(ts => ts.Task)
                .Where(ts => ts.Id == taskSubmission.Id)
                .Select(ts => new { ts.Id, ts.TaskId, TaskDescription = ts.Task.Description, ts.UserId, Username = ts.User.Username, ts.Submission, ts.Status, ts.Score, ts.SubmittedAt })
                .FirstOrDefaultAsync();

            return CreatedAtAction(nameof(GetTaskSubmission), new { id = taskSubmission.Id }, createdSubmissionDetails);
        }

        /// <summary>
        /// Оновити існуюче подання завдання (наприклад, статус та оцінку)
        /// </summary>
        /// <param name="id">Ідентифікатор подання</param>
        /// <param name="dto">Оновлені дані подання</param>
        /// <returns>Статус операції</returns>
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateTaskSubmission(int id, TaskSubmissionUpdateDto dto) // Використовуємо DTO для оновлення
        {
            if (!ModelState.IsValid)
            {
                return BadRequest(ModelState);
            }

            var taskSubmissionToUpdate = await _context.TaskSubmissions.FindAsync(id);
            if (taskSubmissionToUpdate == null)
            {
                return NotFound(new { message = $"Подання з ID {id} не знайдено." });
            }

            // Зазвичай TaskId та UserId не змінюються для існуючого подання.
            // Оновлюємо тільки ті поля, які є в TaskSubmissionUpdateDto
            taskSubmissionToUpdate.Status = dto.Status;
            taskSubmissionToUpdate.Score = dto.Score;
            // if(dto.Submission != null) taskSubmissionToUpdate.Submission = dto.Submission; // Якщо дозволено оновлювати текст подання

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await TaskSubmissionExists(id)) // Додав await
                {
                    return NotFound();
                }
                throw;
            }
            return NoContent();
        }

        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteTaskSubmission(int id)
        {
            var taskSubmission = await _context.TaskSubmissions.FindAsync(id);
            if (taskSubmission == null)
            {
                return NotFound(new { message = $"Подання з ID {id} не знайдено." });
            }

            if (await _context.Comments.AnyAsync(c => c.TaskSubmissionId == id))
            {
                return BadRequest(new { message = "Неможливо видалити подання: до нього є коментарі." });
            }

            _context.TaskSubmissions.Remove(taskSubmission);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> TaskSubmissionExists(int id) // Зробив асинхронним
        {
            return await _context.TaskSubmissions.AnyAsync(e => e.Id == id);
        }
    }
}
//
UsersController.cs
//
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using TaskAPIWebApp;
using System.ComponentModel;
using TaskAPIWebApp.Models;
using System.Linq; // Для .ToLower(), .Contains()
using System.Threading.Tasks; // Для Task
using System.Collections.Generic; // Для IEnumerable


namespace TaskAPIWebApp.Controllers
{
    [Route("api/[controller]")]
    [ApiController]
    [DisplayName("Користувачі")]
    [Produces("application/json")]
    public class UsersController : ControllerBase
    {
        private readonly TaskManagementApiContext _context;

        public UsersController(TaskManagementApiContext context)
        {
            _context = context;
        }

        /// <summary>
        /// Отримати список усіх користувачів
        /// </summary>
        /// <param name="search">Пошук за ім'ям користувача (опціонально)</param>
        /// <returns>Список користувачів</returns>
        [HttpGet]
        public async Task<ActionResult<IEnumerable<User>>> GetUsers(string? search)
        {
            var query = _context.Users.AsQueryable();
            if (!string.IsNullOrEmpty(search))
            {
                search = search.ToLower();
                // Пошук тільки за Username, оскільки Email видалено
                query = query.Where(u => u.Username.ToLower().Contains(search));
            }
            return await query.OrderBy(u => u.Username).ToListAsync(); // Додав сортування
        }

        /// <summary>
        /// Отримати користувача за ID
        /// </summary>
        /// <param name="id">Ідентифікатор користувача</param>
        /// <returns>Користувач з указаним ID</returns>
        [HttpGet("{id}")]
        public async Task<ActionResult<User>> GetUser(int id)
        {
            var user = await _context.Users.FindAsync(id);
            if (user == null)
            {
                return NotFound(new { message = $"Користувача з ID {id} не знайдено." });
            }
            return user;
        }

        /// <summary>
        /// Отримати список користувачів для випадних списків (ID та Username)
        /// </summary>
        /// <returns>Список користувачів з ID та Username</returns>
        [HttpGet("lookup")]
        public async Task<ActionResult<IEnumerable<object>>> GetUsersLookup()
        {
            var users = await _context.Users
                .Select(u => new { u.Id, u.Username })
                .OrderBy(u => u.Username)
                .ToListAsync();
            return Ok(users);
        }


        // --- Методи CreateUser, UpdateUser, DeleteUser ---
        // Якщо ти не плануєш керувати користувачами через API (тільки читати їх),
        // ці методи можна закоментувати або видалити.
        // Якщо вони потрібні, їх треба адаптувати до спрощеної моделі User.
        // Нижче приклад, як вони могли б виглядати для спрощеної моделі (тільки Username).

        /// <summary>
        /// Створити нового користувача (спрощена версія)
        /// </summary>
        /// <param name="userInput">Дані нового користувача (тільки Username)</param>
        /// <returns>Створений користувач</returns>
        [HttpPost]
        public async Task<ActionResult<User>> CreateUser([FromBody] UserCreationDto userInput) // Використовуємо DTO
        {
            if (string.IsNullOrWhiteSpace(userInput.Username))
            {
                return BadRequest(new { message = "Ім'я користувача не може бути порожнім." });
            }

            if (await _context.Users.AnyAsync(u => u.Username == userInput.Username))
            {
                return BadRequest(new { message = "Користувач із таким ім'ям вже існує." });
            }

            var user = new User { Username = userInput.Username };

            _context.Users.Add(user);
            await _context.SaveChangesAsync();
            return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
        }

        /// <summary>
        /// Оновити існуючого користувача (спрощена версія)
        /// </summary>
        /// <param name="id">Ідентифікатор користувача</param>
        /// <param name="userInput">Оновлені дані користувача (тільки Username)</param>
        /// <returns>Статус операції</returns>
        [HttpPut("{id}")]
        public async Task<IActionResult> UpdateUser(int id, [FromBody] UserCreationDto userInput) // Використовуємо DTO
        {
            if (string.IsNullOrWhiteSpace(userInput.Username))
            {
                return BadRequest(new { message = "Ім'я користувача не може бути порожнім." });
            }

            var userToUpdate = await _context.Users.FindAsync(id);
            if (userToUpdate == null)
            {
                return NotFound(new { message = $"Користувача з ID {id} не знайдено." });
            }

            // Перевірка унікальності нового Username, якщо він змінюється і не поточний користувач
            if (userToUpdate.Username != userInput.Username && await _context.Users.AnyAsync(u => u.Username == userInput.Username && u.Id != id))
            {
                return BadRequest(new { message = "Користувач із таким новим ім'ям вже існує." });
            }

            userToUpdate.Username = userInput.Username;

            try
            {
                await _context.SaveChangesAsync();
            }
            catch (DbUpdateConcurrencyException)
            {
                if (!await UserExists(id)) // Додав await
                {
                    return NotFound();
                }
                else
                {
                    throw;
                }
            }
            return NoContent();
        }

        /// <summary>
        /// Видалити користувача
        /// </summary>
        /// <param name="id">Ідентифікатор користувача</param>
        /// <returns>Статус операції</returns>
        [HttpDelete("{id}")]
        public async Task<IActionResult> DeleteUser(int id)
        {
            var user = await _context.Users.FindAsync(id);
            if (user == null)
            {
                return NotFound(new { message = $"Користувача з ID {id} не знайдено." });
            }

            // Перевірка: не дозволяємо видаляти, якщо користувач є єдиним адміністратором групи
            // Ця логіка може залишитися, якщо GroupMembers і ролі використовуються
            var isAdminInAnyGroupAsSoleAdmin = await _context.GroupMembers
                .Where(gm => gm.UserId == id && gm.Role == "Адмін") // Припускаємо, що "Адмін" це значення ролі
                .GroupBy(gm => gm.TaskGroupId)
                .Select(g => new { TaskGroupId = g.Key, AdminCount = g.Count(gm_admin => gm_admin.Role == "Адмін") })
                .AnyAsync(g_info => !_context.GroupMembers.Any(other_gm => other_gm.TaskGroupId == g_info.TaskGroupId && other_gm.Role == "Адмін" && other_gm.UserId != id));


            if (isAdminInAnyGroupAsSoleAdmin)
            {
                return BadRequest(new { message = "Неможливо видалити користувача: він є єдиним адміністратором принаймні в одній групі." });
            }

            // Додаткова перевірка: чи пов'язаний користувач з завданнями, коментарями тощо.
            // Якщо так, можливо, краще не видаляти або видаляти каскадно (обережно!)
            // Або заборонити видалення, якщо є залежності.
            if (await _context.Tasks.AnyAsync(t => t.UserId == id) ||
                await _context.Comments.AnyAsync(c => c.UserId == id) ||
                await _context.TaskSubmissions.AnyAsync(ts => ts.UserId == id) ||
                await _context.TaskGroups.AnyAsync(tg => tg.UserId == id) // Якщо User є власником групи
                )
            {
                return BadRequest(new { message = "Неможливо видалити користувача: він пов'язаний з іншими даними (завдання, коментарі, групи тощо)." });
            }


            _context.Users.Remove(user);
            await _context.SaveChangesAsync();
            return NoContent();
        }

        private async Task<bool> UserExists(int id) // Зробив асинхронним
        {
            return await _context.Users.AnyAsync(e => e.Id == id);
        }
    }

    // Додай простий DTO для створення/оновлення користувача, якщо потрібно
    
}
//
wwwroot
comments
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Коментарями</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="/index.html">TaskSystem</a>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                   
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Коментарями</h1>
        <div id="messageContainer"></div>

        <form id="commentForm">
            <h3>Додати новий коментар</h3>
            <div>
                <label for="content">Текст коментаря:</label>
                <textarea id="content" name="content" required rows="4"></textarea>
            </div>
            <div>
                <label for="userIdSelect">Автор (користувач):</label>
                <select id="userIdSelect" name="userId" required>
                    <option value="">Завантаження користувачів...</option>
                </select>
            </div>
            <div>
                <label>Прив'язати до (виберіть ОДНЕ):</label>
                <div>
                    <input type="radio" id="linkToTask" name="linkType" value="task" checked>
                    <label for="linkToTask" style="display: inline-block; margin-right: 15px;">Завдання</label>
                    <input type="radio" id="linkToSubmission" name="linkType" value="submission">
                    <label for="linkToSubmission" style="display: inline-block;">Подання Завдання</label>
                </div>
            </div>
            <div id="taskLinkContainer">
                <label for="taskIdSelect">Завдання:</label>
                <select id="taskIdSelect" name="taskId">
                    <option value="">Завантаження завдань...</option>
                </select>
            </div>
            <div id="taskSubmissionLinkContainer" class="hidden">
                <label for="taskSubmissionIdSelect">Подання завдання:</label>
                <select id="taskSubmissionIdSelect" name="taskSubmissionId">
                    <option value="">Завантаження подань...</option>
                </select>
            </div>
            <button type="submit">Додати Коментар</button>
        </form>

        <div id="editCommentFormContainer" class="hidden">
            <h3>Редагувати коментар</h3>
            <form id="editCommentForm">
                <input type="hidden" id="editCommentId" name="id">
                <div>
                    <label for="editContent">Текст коментаря:</label>
                    <textarea id="editContent" name="content" required rows="4"></textarea>
                </div>
                <input type="hidden" id="editUserIdHidden">
                <input type="hidden" id="editTaskIdHidden">
                <input type="hidden" id="editTaskSubmissionIdHidden">
                <button type="submit">Зберегти Зміни</button>
                <button type="button" id="cancelEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Коментарів</h3>
        <div class="filter-container" style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
            <label for="filterTaskIdSelect" style="margin-bottom: 0;">Фільтр за Завданням:</label>
            <select id="filterTaskIdSelect" style="min-width: 200px;">
                <option value="">Всі завдання</option>
            </select>
            <label for="filterTaskSubmissionIdSelect" style="margin-bottom: 0; margin-left:10px;">Фільтр за Поданням:</label>
            <select id="filterTaskSubmissionIdSelect" style="min-width: 200px;">
                <option value="">Всі подання</option>
            </select>
            <button id="applyFilterBtn" type="button" style="margin-left:10px;">Фільтрувати</button>
            <button id="clearFilterBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Коментар</th>
                    <th>Автор</th>
                    <th>ID Завд.</th>
                    <th>ID Подан.</th>
                    <th>Створено</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="commentsTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        // Специфічний JS для сторінки comments/index.html

        // URL-и API
        const commentsApiUrl = '/api/Comments';
        // usersApiLookupUrl, tasksApiLookupUrl, taskSubmissionsApiLookupUrl - використовуються з common.js, якщо вони там визначені глобально,
        // або їх можна визначити тут, якщо вони потрібні тільки цій сторінці для populateSelectWithOptions.
        // Для наочності я їх тут залишу, але якщо вони в common.js, їх можна прибрати звідси.
        const usersApiLookupUrl = '/api/Users/lookup';
        const tasksApiLookupUrl = '/api/Tasks/lookup';
        const taskSubmissionsApiLookupUrl = '/api/TaskSubmissions/lookup';


        // DOM Елементи
        const commentForm = document.getElementById('commentForm');
        const contentInput = document.getElementById('content');
        const userIdSelect = document.getElementById('userIdSelect');
        const taskIdSelect = document.getElementById('taskIdSelect');
        const taskSubmissionIdSelect = document.getElementById('taskSubmissionIdSelect');
        const linkToTaskRadio = document.getElementById('linkToTask');
        const linkToSubmissionRadio = document.getElementById('linkToSubmission');
        const taskLinkContainer = document.getElementById('taskLinkContainer');
        const taskSubmissionLinkContainer = document.getElementById('taskSubmissionLinkContainer');

        const editCommentForm = document.getElementById('editCommentForm');
        const editCommentFormContainer = document.getElementById('editCommentFormContainer');
        const editCommentIdInput = document.getElementById('editCommentId');
        const editContentInput = document.getElementById('editContent');
        const editUserIdHidden = document.getElementById('editUserIdHidden');
        const editTaskIdHidden = document.getElementById('editTaskIdHidden');
        const editTaskSubmissionIdHidden = document.getElementById('editTaskSubmissionIdHidden');

        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const commentsTableBody = document.getElementById('commentsTableBody');
        // messageContainer визначається і використовується через common.js (якщо showMessage там модифікована)
        // або може бути отриманий тут: const messageContainer = document.getElementById('messageContainer');

        const filterTaskIdSelect = document.getElementById('filterTaskIdSelect');
        const filterTaskSubmissionIdSelect = document.getElementById('filterTaskSubmissionIdSelect');
        const applyFilterBtn = document.getElementById('applyFilterBtn');
        const clearFilterBtn = document.getElementById('clearFilterBtn');

        // Функції, специфічні для цієї сторінки або які використовують глобальні функції з common.js

        function toggleLinkTypeFields() {
            if (linkToTaskRadio.checked) {
                taskLinkContainer.classList.remove('hidden');
                taskSubmissionLinkContainer.classList.add('hidden');
                if (taskSubmissionIdSelect) taskSubmissionIdSelect.value = "";
            } else {
                taskLinkContainer.classList.add('hidden');
                taskSubmissionLinkContainer.classList.remove('hidden');
                if (taskIdSelect) taskIdSelect.value = "";
            }
        }

        async function initializeDropdownsForComments() {
            await populateSelectWithOptions(userIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть автора...');
            await populateSelectWithOptions(taskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Виберіть завдання...');
            await populateSelectWithOptions(taskSubmissionIdSelect, taskSubmissionsApiLookupUrl, 'id', 'displayText', 'Виберіть подання...');

            await populateSelectWithOptions(filterTaskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Всі завдання', true);
            await populateSelectWithOptions(filterTaskSubmissionIdSelect, taskSubmissionsApiLookupUrl, 'id', 'displayText', 'Всі подання', true);

            toggleLinkTypeFields();
        }

        async function fetchComments() {
            let url = commentsApiUrl;
            const params = new URLSearchParams();
            const taskId = filterTaskIdSelect.value;
            const taskSubmissionId = filterTaskSubmissionIdSelect.value;

            if (taskId) params.append('taskId', taskId);
            if (taskSubmissionId) params.append('taskSubmissionId', taskSubmissionId);

            const queryString = params.toString();
            if (queryString) url += `?${queryString}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response)); // common.js
                const comments = await response.json();
                renderComments(comments);
            } catch (error) {
                console.error('Помилка завантаження коментарів:', error);
                showMessage('messageContainer', `Помилка завантаження коментарів: ${error.message}`, 'error'); // common.js
                commentsTableBody.innerHTML = `<tr><td colspan="7" style="text-align:center;">Не вдалося завантажити коментарі. ${escapeHtml(error.message)}</td></tr>`; // common.js
            }
        }

        function renderComments(comments) {
            commentsTableBody.innerHTML = '';
            if (!comments || comments.length === 0) {
                commentsTableBody.innerHTML = '<tr><td colspan="7" style="text-align:center;">Коментарі не знайдено.</td></tr>';
                return;
            }
            comments.forEach(comment => {
                const row = commentsTableBody.insertRow();
                const userName = comment.user ? escapeHtml(comment.user.username) : 'Невідомий'; // common.js
                const createdAt = comment.createdAt ? new Date(comment.createdAt).toLocaleString('uk-UA') : 'N/A';
                row.innerHTML = `
                        <td>${comment.id}</td>
                        <td>${escapeHtml(comment.content)}</td>
                        <td>${userName} (ID: ${comment.userId})</td>
                        <td>${comment.taskId || ''}</td>
                        <td>${comment.taskSubmissionId || ''}</td>
                        <td>${createdAt}</td>
                        <td>
                            <button class="edit-btn" data-id="${comment.id}">Редагувати</button>
                            <button class="delete-btn" data-id="${comment.id}">Видалити</button>
                        </td>
                    `;
            });
        }

        // Обробники подій
        linkToTaskRadio.addEventListener('change', toggleLinkTypeFields);
        linkToSubmissionRadio.addEventListener('change', toggleLinkTypeFields);

        commentForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const content = contentInput.value;
            const userId = userIdSelect.value;
            let taskIdVal = null;
            let taskSubmissionIdVal = null;

            if (linkToTaskRadio.checked) {
                taskIdVal = taskIdSelect.value;
                if (!taskIdVal) { showMessage('messageContainer', 'Будь ласка, виберіть завдання.', 'error'); return; }
            } else {
                taskSubmissionIdVal = taskSubmissionIdSelect.value;
                if (!taskSubmissionIdVal) { showMessage('messageContainer', 'Будь ласка, виберіть подання.', 'error'); return; }
            }
            if (!userId) { showMessage('messageContainer', 'Будь ласка, виберіть автора.', 'error'); return; }

            const commentData = {
                content: content, userId: parseInt(userId),
                taskId: taskIdVal ? parseInt(taskIdVal) : null,
                taskSubmissionId: taskSubmissionIdVal ? parseInt(taskSubmissionIdVal) : null
            };

            console.log('Спроба додати коментар:', JSON.stringify(commentData, null, 2));
            try {
                const response = await fetch(commentsApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(commentData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Коментар успішно додано!', 'success');
                commentForm.reset();
                userIdSelect.value = ""; taskIdSelect.value = ""; taskSubmissionIdSelect.value = "";
                linkToTaskRadio.checked = true; toggleLinkTypeFields();
                fetchComments();
            } catch (error) {
                console.error('Помилка додавання коментаря:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        async function populateEditCommentForm(id) {
            try {
                const response = await fetch(`${commentsApiUrl}/${id}`);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const comment = await response.json();
                editCommentIdInput.value = comment.id;
                editContentInput.value = comment.content;
                editUserIdHidden.value = comment.userId;
                editTaskIdHidden.value = comment.taskId || "";
                editTaskSubmissionIdHidden.value = comment.taskSubmissionId || "";
                editCommentFormContainer.classList.remove('hidden');
                editCommentFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } catch (error) {
                console.error('Помилка завантаження коментаря для редагування:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        }

        editCommentForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editCommentIdInput.value;
            const content = editContentInput.value;
            const userId = parseInt(editUserIdHidden.value);
            const taskId = editTaskIdHidden.value ? parseInt(editTaskIdHidden.value) : null;
            const taskSubmissionId = editTaskSubmissionIdHidden.value ? parseInt(editTaskSubmissionIdHidden.value) : null;
            const commentData = {
                id: parseInt(id), content: content, userId: userId,
                taskId: taskId, taskSubmissionId: taskSubmissionId
            };
            console.log('Спроба оновити коментар:', JSON.stringify(commentData, null, 2));
            try {
                const response = await fetch(`${commentsApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(commentData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Коментар успішно оновлено!', 'success');
                editCommentFormContainer.classList.add('hidden');
                editCommentForm.reset();
                fetchComments();
            } catch (error) {
                console.error('Помилка оновлення коментаря:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelEditBtn.addEventListener('click', () => {
            editCommentFormContainer.classList.add('hidden');
            editCommentForm.reset();
        });

        commentsTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Ви впевнені, що хочете видалити коментар ID: ${id}?`)) {
                    try {
                        const response = await fetch(`${commentsApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Коментар успішно видалено!', 'success');
                        fetchComments();
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                const id = target.dataset.id;
                populateEditCommentForm(id);
            }
        });

        applyFilterBtn.addEventListener('click', fetchComments);
        clearFilterBtn.addEventListener('click', () => {
            filterTaskIdSelect.value = '';
            filterTaskSubmissionIdSelect.value = '';
            fetchComments();
        });

        async function initializePage() {
            await initializeDropdownsForComments(); // Змінена назва функції для уникнення конфліктів
            await fetchComments();
        }

        // Ініціалізація сторінки
        initializePage();
    </script>
</body>
</html>
//
css
site.css
//
/* Загальні стилі */
body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    margin: 0;
    padding: 0;
    color: #333;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* Заголовки */
h1 {
    font-size: 2rem;
    font-weight: bold;
    color: #2c3e50;
    margin-bottom: 1.5rem;
    text-align: center;
}

h3 {
    font-size: 1.25rem;
    font-weight: 600;
    color: #34495e;
    margin-bottom: 0.75rem;
}

/* Інформаційний блок */
.info-block {
    background-color: #ecf0f1;
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    border-left: 4px solid #3498db;
}

    .info-block p {
        margin: 0.25rem 0;
        color: #7f8c8d;
        line-height: 1.5;
    }

/* Форми та поля вводу */
form {
    background-color: #ffffff;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    margin-bottom: 1.5rem;
}

label {
    display: block;
    font-size: 0.875rem;
    font-weight: 500;
    color: #2c3e50;
    margin-bottom: 0.5rem;
}

input[type="text"],
input[type="number"],
textarea,
select {
    width: 100%;
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 1rem;
    box-sizing: border-box;
    transition: border-color 0.3s;
}

    input[type="text"]:focus,
    input[type="number"]:focus,
    textarea:focus,
    select:focus {
        border-color: #3498db;
        outline: none;
    }

textarea {
    resize: vertical;
    min-height: 100px;
}

input[type="submit"],
button {
    padding: 0.5rem 1rem;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1rem;
    transition: background-color 0.3s, transform 0.1s;
}

input[type="submit"] {
    background-color: #27ae60;
    color: #fff;
}

    input[type="submit"]:hover {
        background-color: #219653;
        transform: translateY(-1px);
    }

/* Кнопки */
button.edit-btn {
    background-color: #e67e22;
    color: #fff;
    margin-right: 0.5rem;
}

    button.edit-btn:hover {
        background-color: #d35400;
        transform: translateY(-1px);
    }

button.delete-btn {
    background-color: #e74c3c;
    color: #fff;
}

    button.delete-btn:hover {
        background-color: #c0392b;
        transform: translateY(-1px);
    }

button.cancel-btn {
    background-color: #95a5a6;
    color: #fff;
}

    button.cancel-btn:hover {
        background-color: #7f8c8d;
        transform: translateY(-1px);
    }

/* Повідомлення */
.message {
    padding: 1rem;
    border-radius: 8px;
    margin-bottom: 1.5rem;
    text-align: center;
}

    .message.success {
        background-color: #dff0d8;
        color: #3c763d;
        border: 1px solid #d6e9c6;
    }

    .message.error {
        background-color: #f2dede;
        color: #a94442;
        border: 1px solid #ebccd1;
    }

.hidden {
    display: none;
}

/* Таблиця */
table {
    width: 100%;
    border-collapse: collapse;
    margin-bottom: 1.5rem;
    background-color: #fff;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

th, td {
    border: 1px solid #eee;
    padding: 0.75rem;
    text-align: left;
}

th {
    background-color: #ecf0f1;
    font-weight: 600;
    color: #2c3e50;
    text-transform: uppercase;
    font-size: 0.875rem;
}

td {
    color: #7f8c8d;
}

    td button {
        margin: 0 0.25rem;
    }

/* Модальне вікно */
.modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    justify-content: center;
}

.modal-content {
    background-color: #fff;
    padding: 1.5rem;
    border-radius: 8px;
    max-width: 500px;
    width: 100%;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

    .modal-content h3 {
        font-size: 1.5rem;
        color: #2c3e50;
        margin-bottom: 1rem;
    }

.flex {
    display: flex;
}

.space-x-2 > * + * {
    margin-left: 0.5rem;
}

.justify-end {
    justify-content: flex-end;
}

/* Додаткові стилі для інтерактивності */
button:active {
    transform: translateY(0);
    }/* --- СТИЛІ ДЛЯ ХЕДЕРА (ШАПКИ САЙТУ) --- */
    header {
        background-color: #2c3e50; /* Темно-синій, насичений колір */
        color: #ffffff;
        padding: 12px 0; /* Вертикальні відступи */
        border-bottom: 3px solid #3498db; /* Яскравий акцент знизу */
        position: sticky; /* "Липкий" хедер при прокрутці */
        top: 0;
        left: 0;
        width: 100%;
        z-index: 1000; /* Щоб був поверх іншого контенту */
        box-sizing: border-box;
    }

    .header-container {
        max-width: 1200px; /* Або інша ширина твого основного контейнера */
        margin: 0 auto;
        padding: 0 20px; /* Бічні відступи */
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .logo a {
        font-size: 1.75rem; /* Розмір тексту логотипу */
        font-weight: 700;   /* Жирний шрифт */
        color: #ffffff;
        text-decoration: none;
        letter-spacing: 1px; /* Невеликий розрив між літерами */
    }

    .main-nav ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex; /* Елементи навігації в ряд */
        align-items: center; /* Вирівнювання по центру по вертикалі */
        gap: 5px; /* Невеликий відступ між пунктами меню */
    }

    .main-nav a {
        color: #ecf0f1; /* Світло-сірий для тексту посилань */
        text-decoration: none;
        padding: 10px 15px; /* Відступи всередині посилань */
        border-radius: 4px; /* Легке заокруглення кутів */
        font-weight: 500; /* Середня жирність шрифту */
        transition: background-color 0.25s ease-out, color 0.25s ease-out; /* Плавний перехід */
        display: block; /* Для правильного застосування padding */
    }

    .main-nav a:hover,
    .main-nav a:focus { /* :focus для доступності */
        background-color: #3498db; /* Яскраво-синій фон при наведенні/фокусі */
        color: #ffffff;
        outline: none; /* Прибираємо стандартний outline при фокусі, якщо фон змінюється */
    }

    .main-nav a.active { /* Клас для активного (поточного) посилання */
        background-color: #2980b9; /* Трохи темніший синій для активного посилання */
        color: #ffffff;
        font-weight: 700; /* Можна зробити активне посилання жирнішим */
    }

    /* --- Кнопка для мобільної навігації ("бургер") --- */
    .mobile-nav-toggle {
        display: none; /* Приховано на десктопних версіях */
        background-color: transparent;
        border: none;
        color: #ffffff;
        cursor: pointer;
        padding: 8px; /* Відступи для кнопки */
        margin-left: 15px; /* Відступ зліва, якщо потрібно */
    }

    .mobile-nav-toggle .icon-bar {
        display: block;
        width: 24px; /* Ширина "паличок" бургера */
        height: 3px;  /* Товщина "паличок" */
        background-color: #ffffff;
        border-radius: 1px; /* Легке заокруглення "паличок" */
        margin: 5px 0; /* Відстань між "паличками" */
        transition: all 0.3s ease-in-out; /* Анімація для перетворення в "хрестик" */
    }

    /* Анімація "бургера" в "хрестик" при активному мобільному меню */
    /* Ця логіка припускає, що JavaScript додає клас 'active' до .main-nav */
    /* Щоб анімувати бургер, потрібно додавати клас, наприклад, 'toggled' до .mobile-nav-toggle */
    /* Якщо ваш common.js додає клас 'active' до .main-nav, то стилі для .icon-bar */
    /* можна прив'язати до стану батьківського .mobile-nav-toggle, якщо йому теж додається клас. */
    /* Приклад нижче, якщо JS додає клас 'nav-toggled' до кнопки .mobile-nav-toggle */

    .mobile-nav-toggle.nav-toggled .icon-bar:nth-child(1) {
        transform: translateY(8px) rotate(45deg);
    }
    .mobile-nav-toggle.nav-toggled .icon-bar:nth-child(2) {
        opacity: 0;
    }
    .mobile-nav-toggle.nav-toggled .icon-bar:nth-child(3) {
        transform: translateY(-8px) rotate(-45deg);
    }


    /* --- Адаптивність для мобільної навігації --- */
    @media (max-width: 992px) { /* Точка перелому (breakpoint) */
        .main-nav {
            display: none; /* Приховуємо навігацію за замовчуванням */
            position: absolute;
            top: 100%; /* Розташовуємо під хедером (потрібно перевірити висоту хедера) */
            left: 0;
            right: 0; /* або width: 100%; */
            background-color: #3a536b; /* Трохи світліший фон для випадаючого меню */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* Тінь для випадаючого меню */
            padding-top: 10px;
            padding-bottom: 10px;
        }

        .main-nav.active { /* Клас, що додається JavaScript для показу меню */
            display: block;
        }

        .main-nav ul {
            flex-direction: column; /* Посилання одне під одним */
            align-items: stretch;   /* Розтягнути елементи по ширині */
            gap: 0; /* Прибираємо горизонтальні відступи */
        }

        .main-nav li {
            width: 100%;
        }

        .main-nav a {
            text-align: center; /* Текст посилань по центру */
            padding: 12px 20px; /* Збільшені відступи для легшого натискання пальцем */
            border-bottom: 1px solid #4f6a85; /* Розділювач між пунктами */
            border-radius: 0; /* Прибираємо заокруглення для повноекранного вигляду */
        }

        .main-nav li:last-child a {
            border-bottom: none; /* Прибираємо розділювач для останнього елемента */
        }

        .main-nav a:hover,
        .main-nav a:focus,
        .main-nav a.active {
            background-color: #3498db; /* Такий самий колір для активності/наведення */
            color: #ffffff;
        }

        .mobile-nav-toggle {
            display: block; /* Показуємо кнопку "бургера" */
        }
    }
//
groupmembers
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Членами Груп</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="/index.html">TaskSystem</a>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                  
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Членами Груп</h1>
        <div id="messageContainer"></div>

        <form id="groupMemberForm">
            <h3>Додати члена до групи</h3>
            <div>
                <label for="gmUserIdSelect">Користувач:</label> <select id="gmUserIdSelect" name="userId" required>
                    <option value="">Завантаження користувачів...</option>
                </select>
            </div>
            <div>
                <label for="gmTaskGroupIdSelect">Група завдань:</label> <select id="gmTaskGroupIdSelect" name="taskGroupId" required>
                    <option value="">Завантаження груп...</option>
                </select>
            </div>
            <div>
                <label for="gmRoleSelect">Роль:</label> <select id="gmRoleSelect" name="role" required>
                    <option value="">Виберіть роль...</option>
                </select>
            </div>
            <button type="submit">Додати Члена</button>
        </form>

        <div id="editGroupMemberFormContainer" class="hidden">
            <h3>Редагувати роль члена групи</h3>
            <form id="editGroupMemberForm">
                <input type="hidden" id="editGmUserIdHidden">
                <input type="hidden" id="editGmTaskGroupIdHidden">
                <div><label>Користувач:</label><p id="editGmUsernameDisplay"></p></div>
                <div><label>Група завдань:</label><p id="editGmTaskGroupNameDisplay"></p></div>
                <div>
                    <label for="editGmRoleSelect">Роль:</label> <select id="editGmRoleSelect" name="role" required>
                        <option value="">Виберіть роль...</option>
                    </select>
                </div>
                <button type="submit">Зберегти Роль</button>
                <button type="button" id="cancelGmEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Членів Груп</h3>
        <div class="filter-container" style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <label for="filterGmTaskGroupIdSelect" style="margin-bottom: 0;">Фільтр за Групою:</label> <select id="filterGmTaskGroupIdSelect" style="min-width: 200px;">
                <option value="">Всі групи</option>
            </select>
            <button id="applyGmFilterBtn" type="button" style="margin-left:10px;">Фільтрувати</button> <button id="clearGmFilterBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>Користувач (ID)</th>
                    <th>Група (ID)</th>
                    <th>Роль</th>
                    <th>Дата приєднання</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="groupMembersTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        // Специфічний JS для сторінки groupmembers/index.html
        const groupMembersApiUrl = '/api/GroupMembers';
        // usersApiLookupUrl, taskGroupsApiLookupUrl - використовуються з common.js
        const usersApiLookupUrl = '/api/Users/lookup';
        const taskGroupsApiLookupUrl = '/api/TaskGroups/lookup';

        const predefinedRoles = ["Member", "Admin", "Viewer"];

        // DOM Елементи
        const groupMemberForm = document.getElementById('groupMemberForm');
        const gmUserIdSelect = document.getElementById('gmUserIdSelect'); // Змінені ID
        const gmTaskGroupIdSelect = document.getElementById('gmTaskGroupIdSelect');
        const gmRoleSelect = document.getElementById('gmRoleSelect');

        const editGroupMemberForm = document.getElementById('editGroupMemberForm');
        const editGroupMemberFormContainer = document.getElementById('editGroupMemberFormContainer');
        const editGmUserIdHidden = document.getElementById('editGmUserIdHidden');
        const editGmTaskGroupIdHidden = document.getElementById('editGmTaskGroupIdHidden');
        const editGmUsernameDisplay = document.getElementById('editGmUsernameDisplay');
        const editGmTaskGroupNameDisplay = document.getElementById('editGmTaskGroupNameDisplay');
        const editGmRoleSelect = document.getElementById('editGmRoleSelect');

        const cancelGmEditBtn = document.getElementById('cancelGmEditBtn'); // Змінений ID
        const groupMembersTableBody = document.getElementById('groupMembersTableBody');

        const filterGmTaskGroupIdSelect = document.getElementById('filterGmTaskGroupIdSelect'); // Змінений ID
        const applyGmFilterBtn = document.getElementById('applyGmFilterBtn'); // Змінений ID
        const clearGmFilterBtn = document.getElementById('clearGmFilterBtn'); // Змінений ID

        function populateGmRoleSelect(selectElement) { // Локальна функція для уникнення конфліктів, якщо predefinedRoles різні
            populateGenericSelect(selectElement, predefinedRoles.map(r => ({ value: r, text: r })), 'value', 'text', 'Виберіть роль...');
        }

        async function initializeDropdownsForGroupMembers() {
            await populateSelectWithOptions(gmUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть користувача...');
            await populateSelectWithOptions(gmTaskGroupIdSelect, taskGroupsApiLookupUrl, 'id', 'name', 'Виберіть групу...');
            populateGmRoleSelect(gmRoleSelect); // Використовуємо локальну

            await populateSelectWithOptions(filterGmTaskGroupIdSelect, taskGroupsApiLookupUrl, 'id', 'name', 'Всі групи', true);
            populateGmRoleSelect(editGmRoleSelect); // Використовуємо локальну
        }

        async function fetchGroupMembers(filterGroupId = null) {
            let url = groupMembersApiUrl;
            if (filterGroupId) {
                url += `?taskGroupId=${filterGroupId}`;
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const members = await response.json();
                renderGroupMembers(members);
            } catch (error) {
                console.error('Помилка завантаження членів груп:', error);
                showMessage('messageContainer', `Помилка завантаження членів груп: ${error.message}`, 'error');
                groupMembersTableBody.innerHTML = `<tr><td colspan="5" style="text-align:center;">Не вдалося завантажити дані. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderGroupMembers(members) {
            groupMembersTableBody.innerHTML = '';
            if (!members || members.length === 0) {
                groupMembersTableBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Члени групи не знайдені.</td></tr>';
                return;
            }
            members.forEach(member => {
                const row = groupMembersTableBody.insertRow();
                const joinedAt = member.joinedAt ? new Date(member.joinedAt).toLocaleDateString('uk-UA') : 'N/A';
                row.innerHTML = `
                        <td>${escapeHtml(member.username)} (ID: ${member.userId})</td>
                        <td>${escapeHtml(member.taskGroupName)} (ID: ${member.taskGroupId})</td>
                        <td>${escapeHtml(member.role)}</td>
                        <td>${joinedAt}</td>
                        <td>
                            <button class="edit-btn" data-user-id="${member.userId}" data-group-id="${member.taskGroupId}" data-username="${escapeHtml(member.username)}" data-groupname="${escapeHtml(member.taskGroupName)}" data-role="${escapeHtml(member.role)}">Редагувати Роль</button>
                            <button class="delete-btn" data-user-id="${member.userId}" data-group-id="${member.taskGroupId}">Видалити</button>
                        </td>
                    `;
            });
        }

        groupMemberForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const userId = gmUserIdSelect.value;
            const taskGroupId = gmTaskGroupIdSelect.value;
            const role = gmRoleSelect.value;

            if (!userId || !taskGroupId || !role) {
                showMessage('messageContainer', 'Будь ласка, заповніть всі обов\'язкові поля.', 'error'); return;
            }
            const memberData = { userId: parseInt(userId), taskGroupId: parseInt(taskGroupId), role: role };
            console.log('Спроба додати члена групи:', JSON.stringify(memberData, null, 2));
            try {
                const response = await fetch(groupMembersApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(memberData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Члена групи успішно додано!', 'success');
                groupMemberForm.reset(); gmUserIdSelect.value = ""; gmTaskGroupIdSelect.value = ""; gmRoleSelect.value = "";
                fetchGroupMembers(filterGmTaskGroupIdSelect.value);
            } catch (error) {
                console.error('Помилка додавання члена групи:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        function populateEditGroupMemberForm(userId, groupId, username, groupName, currentRole) {
            editGmUserIdHidden.value = userId;
            editGmTaskGroupIdHidden.value = groupId;
            editGmUsernameDisplay.textContent = username;
            editGmTaskGroupNameDisplay.textContent = groupName;
            editGmRoleSelect.value = currentRole;
            editGroupMemberFormContainer.classList.remove('hidden');
            editGroupMemberFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        editGroupMemberForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const userId = editGmUserIdHidden.value;
            const taskGroupId = editGmTaskGroupIdHidden.value;
            const role = editGmRoleSelect.value;

            if (!role) { showMessage('messageContainer', 'Будь ласка, виберіть нову роль.', 'error'); return; }
            const roleData = { role: role };
            console.log('Спроба оновити роль члена:', JSON.stringify(roleData, null, 2));
            try {
                const response = await fetch(`${groupMembersApiUrl}/user/${userId}/group/${taskGroupId}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(roleData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Роль члена групи успішно оновлено!', 'success');
                editGroupMemberFormContainer.classList.add('hidden'); editGroupMemberForm.reset();
                fetchGroupMembers(filterGmTaskGroupIdSelect.value);
            } catch (error) {
                console.error('Помилка оновлення ролі:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelGmEditBtn.addEventListener('click', () => { // Змінений ID
            editGroupMemberFormContainer.classList.add('hidden');
            editGroupMemberForm.reset();
        });

        groupMembersTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const userId = target.dataset.userId; const groupId = target.dataset.groupId;
                if (confirm(`Видалити члена (User ID: ${userId}) з групи (Group ID: ${groupId})?`)) {
                    try {
                        const response = await fetch(`${groupMembersApiUrl}/user/${userId}/group/${groupId}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Члена групи успішно видалено!', 'success');
                        fetchGroupMembers(filterGmTaskGroupIdSelect.value);
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                const userId = target.dataset.userId; const groupId = target.dataset.groupId;
                const username = target.dataset.username; const groupName = target.dataset.groupname;
                const currentRole = target.dataset.role;
                populateEditGroupMemberForm(userId, groupId, username, groupName, currentRole);
            }
        });

        applyGmFilterBtn.addEventListener('click', () => fetchGroupMembers(filterGmTaskGroupIdSelect.value)); // Змінений ID
        clearGmFilterBtn.addEventListener('click', () => { // Змінений ID
            filterGmTaskGroupIdSelect.value = ''; fetchGroupMembers();
        });

        async function initializePage() {
            await initializeDropdownsForGroupMembers(); // Змінена назва функції
            await fetchGroupMembers();
        }
        initializePage();
    </script>
</body>
</html>
//
js
common.js
//
// --- wwwroot/js/common.js ---

/**
 * Відображає повідомлення для користувача.
 * @param {string} containerId - ID HTML-елемента, де буде відображено повідомлення.
 * @param {string} text - Текст повідомлення.
 * @param {string} type - Тип повідомлення ('success', 'error', 'info').
 */
function showMessage(containerId, text, type = 'success') {
    const messageContainer = document.getElementById(containerId);
    if (!messageContainer) {
        console.error(`Message container with id '${containerId}' not found.`);
        return;
    }
    messageContainer.innerHTML = ''; // Очистити попередні повідомлення
    const messageDiv = document.createElement('div');
    messageDiv.className = `message ${type}`; // Класи для стилізації (мають бути в site.css)
    messageDiv.textContent = text;
    messageContainer.appendChild(messageDiv);

    // Автоматичне приховування повідомлення через деякий час
    setTimeout(() => {
        if (messageDiv.parentNode === messageContainer) { // Перевірка, чи елемент ще існує
            messageContainer.innerHTML = '';
        }
    }, 4000); // 4 секунди
}

/**
 * Екранує спеціальні HTML-символи для безпечного відображення тексту.
 * @param {string | number | null | undefined} unsafe - Текст для екранування.
 * @returns {string} Екранований текст.
 */
function escapeHtml(unsafe) {
    if (unsafe === null || typeof unsafe === 'undefined') {
        return '';
    }
    return unsafe.toString()
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

/**
 * Обробляє помилкову відповідь від API та повертає текст помилки.
 * @param {Response} response - Об'єкт Response від fetch.
 * @returns {Promise<string>} Текст помилки.
 */
async function handleApiResponseError(response) {
    let errorMessage = `Помилка ${response.status}: ${response.statusText || 'Невідома помилка сервера'}`;
    try {
        const errorData = await response.json();
        if (errorData) {
            if (errorData.message) {
                errorMessage = errorData.message;
            } else if (errorData.title && errorData.errors) { // Стандартні помилки валідації ASP.NET Core ModelState
                const errorDetails = Object.values(errorData.errors).flat().join('; ');
                errorMessage = `${errorData.title}${errorDetails ? ': ' + errorDetails : ''}`;
            } else if (typeof errorData === 'string' && errorData.length > 0 && errorData.length < 500) { // Якщо тіло помилки просто рядок
                errorMessage = errorData;
            } else if (response.status === 400 && errorData.errors) { // Інший формат помилок валідації
                const errorDetails = Object.keys(errorData.errors)
                    .map(key => `${key}: ${errorData.errors[key].join(', ')}`)
                    .join('; ');
                errorMessage = `Помилка валідації: ${errorDetails}`;
            }
        }
    } catch (e) {
        // Якщо тіло відповіді не JSON або порожнє, залишити початкове повідомлення
        const textResponse = await response.text(); // Спробуємо прочитати як текст
        if (textResponse && textResponse.length > 0 && textResponse.length < 500) {
            errorMessage = textResponse;
        }
        console.warn('Не вдалося розпарсити тіло помилки як JSON:', e);
    }
    return errorMessage;
}

/**
 * Заповнює HTML-елемент <select> опціями з наданого масиву.
 * @param {HTMLSelectElement} selectElement - Елемент <select> для заповнення.
 * @param {Array<Object>} items - Масив об'єктів для створення опцій.
 * @param {string} valueField - Назва поля в об'єкті items, яке буде використовуватися як value для опції.
 * @param {string} textField - Назва поля в об'єкті items, яке буде використовуватися як текст опції.
 * @param {string} defaultOptionText - Текст для першої (дефолтної/порожньої) опції.
 * @param {boolean} addEmptyOptionAsDefault - Чи додавати першу порожню опцію.
 */
function populateGenericSelect(selectElement, items, valueField, textField, defaultOptionText, addEmptyOptionAsDefault = true) {
    if (!selectElement) {
        // console.warn(`populateGenericSelect: selectElement is null or undefined.`);
        return;
    }
    selectElement.innerHTML = ''; // Очищення попередніх опцій
    if (addEmptyOptionAsDefault) {
        const defaultOpt = document.createElement('option');
        defaultOpt.value = ""; // Порожнє значення для "Всі" або "Виберіть"
        defaultOpt.textContent = defaultOptionText;
        selectElement.appendChild(defaultOpt);
    }
    if (items && Array.isArray(items)) {
        items.forEach(item => {
            const option = document.createElement('option');
            option.value = item[valueField];
            option.textContent = item[textField];
            selectElement.appendChild(option);
        });
    } else {
        console.warn(`populateGenericSelect: items is not an array or is undefined for selectElement id: ${selectElement.id}`);
    }
}

/**
 * Асинхронно завантажує дані з API та заповнює елемент <select>.
 * @param {HTMLSelectElement} selectElement - Елемент <select> для заповнення.
 * @param {string} apiUrl - URL для отримання даних.
 * @param {string} valueField - Назва поля для value опції.
 * @param {string} textField - Назва поля для тексту опції.
 * @param {string} defaultOptionText - Текст для дефолтної опції.
 * @param {boolean} isFilter - Чи використовується цей селект для фільтра (впливає на текст "Завантаження...").
 */
async function populateSelectWithOptions(selectElement, apiUrl, valueField, textField, defaultOptionText, isFilter = false) {
    if (!selectElement) {
        // console.warn(`populateSelectWithOptions: selectElement for API ${apiUrl} not found on this page.`);
        return; // Просто виходимо, якщо селекта немає на сторінці
    }
    const initialOptionText = isFilter ? defaultOptionText : "Завантаження...";
    selectElement.innerHTML = `<option value="">${initialOptionText}</option>`; // Початкове повідомлення
    try {
        const response = await fetch(apiUrl);
        if (!response.ok) {
            throw new Error(`Не вдалося завантажити дані (${response.status}) для ${selectElement.id || 'селекта'} з ${apiUrl}`);
        }
        const items = await response.json();
        populateGenericSelect(selectElement, items, valueField, textField, defaultOptionText, true);
    } catch (error) {
        console.error(error.message);
        selectElement.innerHTML = `<option value="">Помилка завантаження</option>`;
        // Можна викликати showMessage тут, якщо є глобальний контейнер повідомлень
        // showMessage('messageContainer', error.message, 'error');
    }
}


// --- Логіка для мобільної навігації та активного посилання в хедері ---
document.addEventListener('DOMContentLoaded', () => {
    const mobileNavToggle = document.querySelector('.mobile-nav-toggle');
    const mainNav = document.querySelector('.main-nav'); // Селектор для <nav class="main-nav">

    if (mobileNavToggle && mainNav) {
        mobileNavToggle.addEventListener('click', () => {
            const isExpanded = mobileNavToggle.getAttribute('aria-expanded') === 'true' || false;
            mobileNavToggle.setAttribute('aria-expanded', !isExpanded);
            mainNav.classList.toggle('active'); // Додаємо/видаляємо клас для показу/приховування меню

            // Анімація "бургера" в "хрестик" (якщо стилі для цього є в site.css)
            const iconBars = mobileNavToggle.querySelectorAll('.icon-bar');
            if (mainNav.classList.contains('active')) {
                if (iconBars.length === 3) {
                    // Стилі для "хрестика" краще задавати через CSS класи,
                    // але для прикладу можна й так, якщо стилі бургера це дозволяють.
                    // Наприклад, можна додати клас .is-active до mobileNavToggle
                    // і стилізувати .icon-bar всередині .is-active.
                    // Поки що залишаю без прямої зміни стилів іконок тут,
                    // бо ти просив спростити CSS раніше.
                }
            } else {
                // Повернення до вигляду "бургера"
            }
        });
    }

    // Підсвічування активного посилання в навігації
    try {
        const currentPath = window.location.pathname;
        const navLinks = document.querySelectorAll('.main-nav a'); // Переконайся, що це правильний селектор для посилань

        navLinks.forEach(link => {
            link.classList.remove('active'); // Спочатку знімаємо клас з усіх
            const linkHref = link.getAttribute('href');

            if (linkHref) {
                // Точна відповідність або відповідність для головної сторінки
                if (linkHref === currentPath || (linkHref === '/index.html' && currentPath === '/')) {
                    link.classList.add('active');
                }
                // Для інших сторінок, якщо шлях починається з href посилання (і воно не є просто '/')
                // Це дозволяє підсвічувати /tasks/index.html, коли поточний шлях /tasks/ або /tasks/index.html
                else if (linkHref !== '/' && linkHref !== '/index.html' && currentPath.startsWith(linkHref.replace(/index\.html$/, ''))) {
                    if (currentPath.startsWith(linkHref) || currentPath.startsWith(linkHref.substring(0, linkHref.lastIndexOf('/') + 1 || linkHref.length))) {
                        link.classList.add('active');
                    }
                }
            }
        });

        // Якщо після всіх перевірок жодне посилання не активне, і ми на головній сторінці
        const activeLink = document.querySelector('.main-nav a.active');
        if (!activeLink && (currentPath === '/' || currentPath === '/index.html')) {
            const homeLink = document.querySelector('.main-nav a[href="/index.html"], .main-nav a[href="/"]');
            if (homeLink) {
                homeLink.classList.add('active');
            }
        }

    } catch (e) {
        console.error("Помилка підсвічування активного посилання:", e);
    }
});
//
taskattachments
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Вкладеннями Завдань</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo"><a href="/index.html">TaskSystem</a></div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                    
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Вкладеннями Завдань</h1>
        <div id="messageContainer"></div>

        <form id="attachmentForm">
            <h3>Додати нове вкладення</h3>
            <div>
                <label for="attTaskIdSelect">Завдання (до якого прикріпити):</label>
                <select id="attTaskIdSelect" name="taskId" required>
                    <option value="">Завантаження завдань...</option>
                </select>
            </div>
            <div>
                <label for="filePath">Шлях до файлу (поточна імплементація):</label>
                <input type="text" id="filePath" name="filePath" required placeholder="/uploads/example.pdf">
            </div>
            <button type="submit">Додати Вкладення</button>
        </form>

        <div id="editAttachmentFormContainer" class="hidden">
            <h3>Редагувати шлях вкладення</h3>
            <form id="editAttachmentForm">
                <input type="hidden" id="editAttachmentId">
                <div>
                    <label>Завдання:</label>
                    <p id="editAttTaskDisplay"></p> <input type="hidden" id="editAttTaskIdHidden">
                </div>
                <div>
                    <label for="editFilePath">Новий шлях до файлу:</label>
                    <input type="text" id="editFilePath" name="filePath" required>
                </div>
                <button type="submit">Зберегти Шлях</button>
                <button type="button" id="cancelAttEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Вкладень</h3>
        <div class="filter-container" style="margin-bottom: 1rem;">
            <label for="filterAttTaskIdSelect">Фільтр за Завданням:</label>
            <select id="filterAttTaskIdSelect" style="min-width: 200px;">
                <option value="">Всі завдання</option>
            </select>
            <button id="applyAttFilterBtn" type="button" style="margin-left:10px;">Фільтрувати</button>
            <button id="clearAttFilterBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Завдання</th>
                    <th>Шлях до файлу</th>
                    <th>Завантажено</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="attachmentsTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        const attachmentsApiUrl = '/api/TaskAttachments';
        const tasksApiLookupUrl = '/api/Tasks/lookup'; // Потрібен для вибору завдання

        // DOM Elements
        const attachmentForm = document.getElementById('attachmentForm');
        const attTaskIdSelect = document.getElementById('attTaskIdSelect');
        const filePathInput = document.getElementById('filePath');
        // const fileUploadInput = document.getElementById('fileUpload'); // Для реального завантаження

        const editAttachmentFormContainer = document.getElementById('editAttachmentFormContainer');
        const editAttachmentForm = document.getElementById('editAttachmentForm');
        const editAttachmentIdInput = document.getElementById('editAttachmentId');
        const editAttTaskDisplay = document.getElementById('editAttTaskDisplay');
        const editAttTaskIdHidden = document.getElementById('editAttTaskIdHidden');
        const editFilePathInput = document.getElementById('editFilePath');
        const cancelAttEditBtn = document.getElementById('cancelAttEditBtn');

        const attachmentsTableBody = document.getElementById('attachmentsTableBody');
        const filterAttTaskIdSelect = document.getElementById('filterAttTaskIdSelect');
        const applyAttFilterBtn = document.getElementById('applyAttFilterBtn');
        const clearAttFilterBtn = document.getElementById('clearAttFilterBtn');

        async function initializeDropdownsForAttachments() {
            await populateSelectWithOptions(attTaskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Виберіть завдання...');
            await populateSelectWithOptions(filterAttTaskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Всі завдання', true);
        }

        async function fetchAttachments(filterTaskId = null) {
            let url = attachmentsApiUrl;
            if (filterTaskId) {
                url += `?taskId=${filterTaskId}`;
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const attachments = await response.json();
                renderAttachments(attachments);
            } catch (error) {
                console.error('Помилка завантаження вкладень:', error);
                showMessage('messageContainer', `Помилка завантаження вкладень: ${error.message}`, 'error');
                attachmentsTableBody.innerHTML = `<tr><td colspan="5">Не вдалося завантажити дані. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderAttachments(attachments) {
            attachmentsTableBody.innerHTML = '';
            if (!attachments || attachments.length === 0) {
                attachmentsTableBody.innerHTML = '<tr><td colspan="5" style="text-align:center;">Вкладення не знайдено.</td></tr>';
                return;
            }
            attachments.forEach(att => {
                const row = attachmentsTableBody.insertRow();
                const uploadedAt = att.uploadedAt ? new Date(att.uploadedAt).toLocaleString('uk-UA') : 'N/A';
                // Робимо FilePath клікабельним, якщо це відносний шлях, який можна відкрити
                const filePathDisplay = att.filePath.startsWith('/') || att.filePath.startsWith('http')
                                      ? `<a href="${escapeHtml(att.filePath)}" target="_blank">${escapeHtml(att.filePath)}</a>`
                                      : escapeHtml(att.filePath);
                row.innerHTML = `
                    <td>${att.id}</td>
                    <td>${escapeHtml(att.taskDescription)} (ID: ${att.taskId})</td>
                    <td>${filePathDisplay}</td>
                    <td>${uploadedAt}</td>
                    <td>
                        <button class="edit-btn" data-id="${att.id}" data-task-id="${att.taskId}" data-task-desc="${escapeHtml(att.taskDescription)}" data-filepath="${escapeHtml(att.filePath)}">Редагувати Шлях</button>
                        <button class="delete-btn" data-id="${att.id}">Видалити</button>
                    </td>
                `;
            });
        }

        attachmentForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const taskId = attTaskIdSelect.value;
            const filePath = filePathInput.value; // Поки що беремо шлях з інпуту

            if (!taskId) { showMessage('messageContainer', 'Будь ласка, виберіть завдання.', 'error'); return; }
            if (!filePath.trim()) { showMessage('messageContainer', 'Будь ласка, вкажіть шлях до файлу.', 'error'); return; }

            const attachmentData = { taskId: parseInt(taskId), filePath: filePath };

            // Для реального завантаження файлу:
            // const formData = new FormData();
            // formData.append('taskId', taskId);
            // formData.append('file', fileUploadInput.files[0]);
            // console.log('Спроба додати вкладення (файл):', fileUploadInput.files[0] ? fileUploadInput.files[0].name : 'файл не вибрано');
            // try {
            //     const response = await fetch(attachmentsApiUrl, { method: 'POST', body: formData }); // Без Content-Type для FormData
            // ...
            // }

            console.log('Спроба додати вкладення (шлях):', JSON.stringify(attachmentData, null, 2));
            try {
                const response = await fetch(attachmentsApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(attachmentData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Вкладення успішно додано!', 'success');
                attachmentForm.reset(); attTaskIdSelect.value = "";
                fetchAttachments(filterAttTaskIdSelect.value);
            } catch (error) {
                console.error('Помилка додавання вкладення:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        function populateEditAttachmentForm(id, taskId, taskDesc, filepath) {
            editAttachmentIdInput.value = id;
            editAttTaskIdHidden.value = taskId; // TaskId не редагуємо, просто зберігаємо
            editAttTaskDisplay.textContent = `${taskDesc} (ID: ${taskId})`;
            editFilePathInput.value = filepath;
            editAttachmentFormContainer.classList.remove('hidden');
            editAttachmentFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        editAttachmentForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editAttachmentIdInput.value;
            const filePath = editFilePathInput.value;
            // TaskId не змінюється при редагуванні шляху, беремо з прихованого поля
            // const taskId = editAttTaskIdHidden.value;

            if (!filePath.trim()) { showMessage('messageContainer', 'Будь ласка, вкажіть новий шлях до файлу.', 'error'); return; }

            const updateData = { filePath: filePath /*, taskId: parseInt(taskId) */ }; // Надсилаємо тільки те, що оновлюємо
            console.log(`Спроба оновити вкладення ID ${id}:`, JSON.stringify(updateData, null, 2));
            try {
                const response = await fetch(`${attachmentsApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(updateData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Шлях вкладення успішно оновлено!', 'success');
                editAttachmentFormContainer.classList.add('hidden'); editAttachmentForm.reset();
                fetchAttachments(filterAttTaskIdSelect.value);
            } catch (error) {
                console.error('Помилка оновлення вкладення:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelAttEditBtn.addEventListener('click', () => {
            editAttachmentFormContainer.classList.add('hidden'); editAttachmentForm.reset();
        });

        attachmentsTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Видалити вкладення ID: ${id}?`)) {
                    try {
                        const response = await fetch(`${attachmentsApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Вкладення успішно видалено!', 'success');
                        fetchAttachments(filterAttTaskIdSelect.value);
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                populateEditAttachmentForm(
                    target.dataset.id,
                    target.dataset.taskId,
                    target.dataset.taskDesc,
                    target.dataset.filepath
                );
            }
        });

        applyAttFilterBtn.addEventListener('click', () => fetchAttachments(filterAttTaskIdSelect.value));
        clearAttFilterBtn.addEventListener('click', () => {
            filterAttTaskIdSelect.value = ''; fetchAttachments();
        });

        async function initializePage() {
            await initializeDropdownsForAttachments();
            await fetchAttachments();
        }
        initializePage();
    </script>
</body>
</html>
//
taskgroups
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Групами Завдань</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo"><a href="/index.html">TaskSystem</a></div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                  
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Групами Завдань</h1>
        <div id="messageContainer"></div>

        <form id="taskGroupForm">
            <h3>Додати нову групу завдань</h3>
            <div>
                <label for="tgName">Назва групи:</label>
                <input type="text" id="tgName" name="name" required>
            </div>
            <div>
                <label for="tgUserIdSelect">Власник групи (користувач):</label>
                <select id="tgUserIdSelect" name="userId" required>
                    <option value="">Завантаження користувачів...</option>
                </select>
            </div>
            <button type="submit">Додати Групу</button>
        </form>

        <div id="editTaskGroupFormContainer" class="hidden">
            <h3>Редагувати групу завдань</h3>
            <form id="editTaskGroupForm">
                <input type="hidden" id="editTgId">
                <div>
                    <label for="editTgName">Назва групи:</label>
                    <input type="text" id="editTgName" name="name" required>
                </div>
                <div>
                    <label for="editTgUserIdSelect">Власник групи (користувач):</label>
                    <select id="editTgUserIdSelect" name="userId" required>
                        <option value="">Завантаження користувачів...</option>
                    </select>
                </div>
                <button type="submit">Зберегти Зміни</button>
                <button type="button" id="cancelTgEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Груп Завдань</h3>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Назва Групи</th>
                    <th>Власник (ID)</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="taskGroupsTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        const taskGroupsApiUrl = '/api/TaskGroups';
        const usersApiLookupUrl = '/api/Users/lookup';

        // DOM Elements
        const taskGroupForm = document.getElementById('taskGroupForm');
        const tgNameInput = document.getElementById('tgName');
        const tgUserIdSelect = document.getElementById('tgUserIdSelect');

        const editTaskGroupFormContainer = document.getElementById('editTaskGroupFormContainer');
        const editTaskGroupForm = document.getElementById('editTaskGroupForm');
        const editTgIdInput = document.getElementById('editTgId');
        const editTgNameInput = document.getElementById('editTgName');
        const editTgUserIdSelect = document.getElementById('editTgUserIdSelect');
        const cancelTgEditBtn = document.getElementById('cancelTgEditBtn');

        const taskGroupsTableBody = document.getElementById('taskGroupsTableBody');
        // const messageContainer = document.getElementById('messageContainer'); // Вже є в common.js, якщо showMessage приймає ID

        async function initializeDropdownsForTaskGroups() {
            await populateSelectWithOptions(tgUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть власника...');
            await populateSelectWithOptions(editTgUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть власника...');
        }

        async function fetchTaskGroups() {
            // Можна додати параметр sortByDate, якщо потрібно
            const url = `${taskGroupsApiUrl}?sortByDate=desc`; // Завантажуємо новіші першими
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const groups = await response.json();
                renderTaskGroups(groups);
            } catch (error) {
                console.error('Помилка завантаження груп завдань:', error);
                showMessage('messageContainer', `Помилка завантаження груп: ${error.message}`, 'error');
                taskGroupsTableBody.innerHTML = `<tr><td colspan="4">Не вдалося завантажити дані. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderTaskGroups(groups) {
            taskGroupsTableBody.innerHTML = '';
            if (!groups || groups.length === 0) {
                taskGroupsTableBody.innerHTML = '<tr><td colspan="4" style="text-align:center;">Групи завдань не знайдено.</td></tr>';
                return;
            }
            groups.forEach(group => {
                const row = taskGroupsTableBody.insertRow();
                row.innerHTML = `
                    <td>${group.id}</td>
                    <td>${escapeHtml(group.name)}</td>
                    <td>${escapeHtml(group.ownerUsername)} (ID: ${group.userId})</td>
                    <td>
                        <button class="edit-btn" data-id="${group.id}" data-name="${escapeHtml(group.name)}" data-userid="${group.userId}">Редагувати</button>
                        <button class="delete-btn" data-id="${group.id}">Видалити</button>
                    </td>
                `;
            });
        }

        taskGroupForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const name = tgNameInput.value;
            const userId = tgUserIdSelect.value;

            if (!name.trim() || !userId) {
                showMessage('messageContainer', 'Будь ласка, заповніть назву групи та виберіть власника.', 'error'); return;
            }

            const groupData = { name: name, userId: parseInt(userId) };
            console.log('Спроба додати групу завдань:', JSON.stringify(groupData, null, 2));

            try {
                const response = await fetch(taskGroupsApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(groupData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Групу завдань успішно додано!', 'success');
                taskGroupForm.reset(); tgUserIdSelect.value = "";
                fetchTaskGroups();
            } catch (error) {
                console.error('Помилка додавання групи завдань:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        function populateEditTaskGroupForm(id, name, userId) {
            editTgIdInput.value = id;
            editTgNameInput.value = name;
            editTgUserIdSelect.value = userId; // Встановлюємо вибраного користувача

            editTaskGroupFormContainer.classList.remove('hidden');
            editTaskGroupFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        editTaskGroupForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editTgIdInput.value;
            const name = editTgNameInput.value;
            const userId = editTgUserIdSelect.value;

            if (!name.trim() || !userId) {
                showMessage('messageContainer', 'Будь ласка, заповніть назву групи та виберіть власника.', 'error'); return;
            }

            const groupData = { id: parseInt(id), name: name, userId: parseInt(userId) };
            console.log(`Спроба оновити групу ID ${id}:`, JSON.stringify(groupData, null, 2));

            try {
                const response = await fetch(`${taskGroupsApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(groupData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Групу завдань успішно оновлено!', 'success');
                editTaskGroupFormContainer.classList.add('hidden'); editTaskGroupForm.reset();
                fetchTaskGroups();
            } catch (error) {
                console.error('Помилка оновлення групи завдань:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelTgEditBtn.addEventListener('click', () => {
            editTaskGroupFormContainer.classList.add('hidden'); editTaskGroupForm.reset();
        });

        taskGroupsTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Видалити групу завдань ID: ${id}? УВАГА: Це може бути неможливо, якщо в групі є завдання або члени.`)) {
                    try {
                        const response = await fetch(`${taskGroupsApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Групу завдань успішно видалено!', 'success');
                        fetchTaskGroups();
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                populateEditTaskGroupForm(target.dataset.id, target.dataset.name, target.dataset.userid);
            }
        });

        // Фільтрація поки що не реалізована для груп, але можна додати за потреби
        // applyFilterBtn.addEventListener('click', () => fetchTaskGroups(filterInput.value));
        // clearFilterBtn.addEventListener('click', () => { filterInput.value = ''; fetchTaskGroups(); });

        async function initializePage() {
            await initializeDropdownsForTaskGroups();
            await fetchTaskGroups();
        }
        initializePage();
    </script>
</body>
</html>
//
tasks
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Завданнями</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="/index.html">TaskSystem</a>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                    
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Завданнями</h1>
        <div id="messageContainer"></div>

        <form id="taskForm">
            <h3>Додати нове завдання</h3>
            <div>
                <label for="description">Опис:</label>
                <textarea id="description" name="description" required></textarea>
            </div>
            <div>
                <label for="statusSelect">Статус:</label>
                <select id="statusSelect" name="status" required>
                    <option value="">Виберіть статус...</option>
                </select>
            </div>
            <div>
                <label for="userIdSelect">Користувач:</label>
                <select id="userIdSelect" name="userId" required>
                    <option value="">Завантаження користувачів...</option>
                </select>
            </div>
            <div>
                <label for="taskGroupIdSelect">Група завдань (необов'язково):</label>
                <select id="taskGroupIdSelect" name="taskGroupId">
                    <option value="">Завантаження груп...</option>
                </select>
            </div>
            <button type="submit">Додати Завдання</button>
        </form>

        <div id="editTaskFormContainer" class="hidden">
            <h3>Редагувати завдання</h3>
            <form id="editTaskForm">
                <input type="hidden" id="editTaskId" name="id">
                <div>
                    <label for="editDescription">Опис:</label>
                    <textarea id="editDescription" name="description" required></textarea>
                </div>
                <div>
                    <label for="editStatusSelect">Статус:</label>
                    <select id="editStatusSelect" name="status" required>
                        <option value="">Виберіть статус...</option>
                    </select>
                </div>
                <div>
                    <label for="editUserIdSelect">Користувач:</label>
                    <select id="editUserIdSelect" name="userId" required>
                        <option value="">Завантаження користувачів...</option>
                    </select>
                </div>
                <div>
                    <label for="editTaskGroupIdSelect">Група завдань (необов'язково):</label>
                    <select id="editTaskGroupIdSelect" name="taskGroupId">
                        <option value="">Завантаження груп...</option>
                    </select>
                </div>
                <button type="submit">Зберегти Зміни</button>
                <button type="button" id="cancelEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Завдань</h3>
        <div class="filter-container" style="margin-bottom: 1rem; display: flex; align-items: center; gap: 0.5rem;">
            <label for="statusFilterInput" style="margin-bottom: 0;">Фільтрувати за статусом (текст):</label> <input type="text" id="statusFilterInput" placeholder="Введіть статус" style="flex-grow: 1;">
            <button id="applyStatusFilterBtn" type="button">Фільтрувати</button> <button id="clearStatusFilterBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Опис</th>
                    <th>Статус</th>
                    <th>ID Користувача</th>
                    <th>ID Групи</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="tasksTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        // Специфічний JS для сторінки tasks/index.html
        const tasksApiUrl = '/api/Tasks';
        const usersApiLookupUrl = '/api/Users/lookup';
        const taskGroupsApiLookupUrl = '/api/TaskGroups/lookup';
        const predefinedStatuses = ["Нове", "В роботі", "Виконано", "Відкладено", "Скасовано", "Чернетка"];

        // DOM Елементи
        const taskForm = document.getElementById('taskForm');
        const descriptionInput = document.getElementById('description');
        const statusSelect = document.getElementById('statusSelect');
        const userIdSelect = document.getElementById('userIdSelect');
        const taskGroupIdSelect = document.getElementById('taskGroupIdSelect');

        const editTaskForm = document.getElementById('editTaskForm');
        const editTaskFormContainer = document.getElementById('editTaskFormContainer');
        const editTaskIdInput = document.getElementById('editTaskId');
        const editDescriptionInput = document.getElementById('editDescription');
        const editStatusSelect = document.getElementById('editStatusSelect');
        const editUserIdSelect = document.getElementById('editUserIdSelect');
        const editTaskGroupIdSelect = document.getElementById('editTaskGroupIdSelect');

        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const tasksTableBody = document.getElementById('tasksTableBody');

        const statusFilterInput = document.getElementById('statusFilterInput'); // Оновлений ID
        const applyStatusFilterBtn = document.getElementById('applyStatusFilterBtn'); // Оновлений ID
        const clearStatusFilterBtn = document.getElementById('clearStatusFilterBtn'); // Оновлений ID

        function populateLocalStatusSelect(selectElement) { // Локальна, якщо predefinedStatuses тут
            populateGenericSelect(selectElement, predefinedStatuses.map(s => ({ value: s, text: s })), 'value', 'text', 'Виберіть статус...');
        }

        async function initializeDropdownsForTasks() {
            populateLocalStatusSelect(statusSelect);
            populateLocalStatusSelect(editStatusSelect);
            await populateSelectWithOptions(userIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть користувача...');
            await populateSelectWithOptions(taskGroupIdSelect, taskGroupsApiLookupUrl, 'id', 'name', 'Без групи');
            await populateSelectWithOptions(editUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть користувача...');
            await populateSelectWithOptions(editTaskGroupIdSelect, taskGroupsApiLookupUrl, 'id', 'name', 'Без групи');
        }

        async function fetchTasks(statusQuery = null) {
            let url = tasksApiUrl;
            if (statusQuery && statusQuery.trim() !== '') {
                url += `?status=${encodeURIComponent(statusQuery.trim())}`;
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const tasks = await response.json();
                renderTasks(tasks);
            } catch (error) {
                console.error('Помилка завантаження завдань:', error);
                showMessage('messageContainer', `Помилка завантаження завдань: ${error.message}`, 'error');
                tasksTableBody.innerHTML = `<tr><td colspan="6" style="text-align:center;">Не вдалося завантажити завдання. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderTasks(tasks) {
            tasksTableBody.innerHTML = '';
            if (!tasks || tasks.length === 0) {
                tasksTableBody.innerHTML = '<tr><td colspan="6" style="text-align:center;">Завдання не знайдено.</td></tr>';
                return;
            }
            tasks.forEach(task => {
                const row = tasksTableBody.insertRow();
                row.innerHTML = `
                        <td>${task.id}</td><td>${escapeHtml(task.description)}</td><td>${escapeHtml(task.status)}</td>
                        <td>${task.userId}</td><td>${task.taskGroupId !== null ? task.taskGroupId : ''}</td>
                        <td>
                            <button class="edit-btn" data-id="${task.id}">Редагувати</button>
                            <button class="delete-btn" data-id="${task.id}">Видалити</button>
                        </td>
                    `;
            });
        }

        taskForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const description = descriptionInput.value;
            const status = statusSelect.value;
            const userIdStr = userIdSelect.value;
            const taskGroupIdStr = taskGroupIdSelect.value;

            if (!status) { showMessage('messageContainer', 'Будь ласка, виберіть статус.', 'error'); return; }
            if (!userIdStr) { showMessage('messageContainer', 'Будь ласка, виберіть користувача.', 'error'); return; }

            const taskData = {
                description: description, status: status, userId: parseInt(userIdStr),
                taskGroupId: taskGroupIdStr ? parseInt(taskGroupIdStr) : null
            };
            console.log('Спроба додати завдання:', JSON.stringify(taskData, null, 2));
            try {
                const response = await fetch(tasksApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(taskData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Завдання успішно додано!', 'success');
                taskForm.reset(); statusSelect.value = ""; userIdSelect.value = ""; taskGroupIdSelect.value = "";
                fetchTasks(statusFilterInput.value);
            } catch (error) {
                console.error('Помилка додавання завдання:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        async function populateEditTaskForm(id) { // Перейменовано populateEditForm
            try {
                const response = await fetch(`${tasksApiUrl}/${id}`);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const task = await response.json();
                editTaskIdInput.value = task.id;
                editDescriptionInput.value = task.description;
                editStatusSelect.value = task.status;
                editUserIdSelect.value = task.userId;
                editTaskGroupIdSelect.value = task.taskGroupId !== null ? task.taskGroupId : '';
                editTaskFormContainer.classList.remove('hidden');
                editTaskFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } catch (error) {
                console.error('Помилка завантаження завдання для редагування:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        }

        editTaskForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editTaskIdInput.value;
            const description = editDescriptionInput.value;
            const status = editStatusSelect.value;
            const userIdStr = editUserIdSelect.value;
            const taskGroupIdStr = editTaskGroupIdSelect.value;

            if (!status) { showMessage('messageContainer', 'Будь ласка, виберіть статус.', 'error'); return; }
            if (!userIdStr) { showMessage('messageContainer', 'Будь ласка, виберіть користувача.', 'error'); return; }

            const taskData = {
                id: parseInt(id), description: description, status: status, userId: parseInt(userIdStr),
                taskGroupId: taskGroupIdStr ? parseInt(taskGroupIdStr) : null
            };
            console.log('Спроба оновити завдання:', JSON.stringify(taskData, null, 2));
            try {
                const response = await fetch(`${tasksApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(taskData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Завдання успішно оновлено!', 'success');
                editTaskFormContainer.classList.add('hidden'); editTaskForm.reset();
                fetchTasks(statusFilterInput.value);
            } catch (error) {
                console.error('Помилка оновлення завдання:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelEditBtn.addEventListener('click', () => {
            editTaskFormContainer.classList.add('hidden'); editTaskForm.reset();
        });

        tasksTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Видалити завдання ID: ${id}?`)) {
                    try {
                        const response = await fetch(`${tasksApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Завдання успішно видалено!', 'success');
                        fetchTasks(statusFilterInput.value);
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                const id = target.dataset.id;
                populateEditTaskForm(id); // Використовуємо перейменовану функцію
            }
        });

        applyStatusFilterBtn.addEventListener('click', () => fetchTasks(statusFilterInput.value)); // Оновлений ID
        clearStatusFilterBtn.addEventListener('click', () => { // Оновлений ID
            statusFilterInput.value = ''; fetchTasks();
        });

        async function initializePage() {
            await initializeDropdownsForTasks(); // Змінена назва функції
            await fetchTasks();
        }
        initializePage();
    </script>
</body>
</html>
//
tasksubmissions
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Поданнями Завдань</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo"><a href="/index.html">TaskSystem</a></div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                    
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <h1>Керування Поданнями Завдань</h1>
        <div id="messageContainer"></div>

        <form id="submissionForm">
            <h3>Додати нове подання</h3>
            <div>
                <label for="subTaskIdSelect">Завдання:</label>
                <select id="subTaskIdSelect" name="taskId" required>
                    <option value="">Завантаження завдань...</option>
                </select>
            </div>
            <div>
                <label for="subUserIdSelect">Користувач (хто подає):</label>
                <select id="subUserIdSelect" name="userId" required>
                    <option value="">Завантаження користувачів...</option>
                </select>
            </div>
            <div>
                <label for="submissionText">Текст/вміст подання:</label>
                <textarea id="submissionText" name="submission" rows="5" required></textarea>
            </div>
            <div>
                <label for="subStatusSelect">Статус подання:</label>
                <select id="subStatusSelect" name="status" required>
                    <option value="">Виберіть статус...</option>
                </select>
            </div>
            <div>
                <label for="score">Оцінка (0-100, необов'язково):</label>
                <input type="number" id="score" name="score" min="0" max="100">
            </div>
            <button type="submit">Додати Подання</button>
        </form>

        <div id="editSubmissionFormContainer" class="hidden">
            <h3>Редагувати подання</h3>
            <form id="editSubmissionForm">
                <input type="hidden" id="editSubId">
                <div>
                    <label>Завдання:</label> <span id="editSubTaskDisplay"></span>
                </div>
                <div>
                    <label>Користувач:</label> <span id="editSubUserDisplay"></span>
                </div>
                <div>
                    <label for="editSubSubmissionText">Текст/вміст подання (можна не давати редагувати):</label>
                    <textarea id="editSubSubmissionText" name="submission" rows="5" readonly></textarea>
                </div>
                <div>
                    <label for="editSubStatusSelect">Статус подання:</label>
                    <select id="editSubStatusSelect" name="status" required>
                        <option value="">Виберіть статус...</option>
                    </select>
                </div>
                <div>
                    <label for="editScore">Оцінка (0-100, необов'язково):</label>
                    <input type="number" id="editScore" name="score" min="0" max="100">
                </div>
                <button type="submit">Зберегти Зміни</button>
                <button type="button" id="cancelSubEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Подань</h3>
        <div class="filter-container" style="margin-bottom: 1rem; display: flex; flex-wrap: wrap; align-items: center; gap: 0.5rem;">
            <label for="filterSubTaskIdSelect">Фільтр за Завданням:</label>
            <select id="filterSubTaskIdSelect" style="min-width: 180px;"><option value="">Всі завдання</option></select>
            <label for="filterSubUserIdSelect" style="margin-left:10px;">Фільтр за Користувачем:</label>
            <select id="filterSubUserIdSelect" style="min-width: 180px;"><option value="">Всі користувачі</option></select>
            <button id="applySubFilterBtn" type="button" style="margin-left:10px;">Фільтрувати</button>
            <button id="clearSubFilterBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Завдання</th>
                    <th>Користувач</th>
                    <th>Подання</th>
                    <th>Статус</th>
                    <th>Оцінка</th>
                    <th>Дата</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="submissionsTableBody"></tbody>
        </table>
    </div>

    <script src="../js/common.js"></script>
    <script>
        const submissionsApiUrl = '/api/TaskSubmissions';
        const tasksApiLookupUrl = '/api/Tasks/lookup';
        const usersApiLookupUrl = '/api/Users/lookup';

        const predefinedSubmissionStatuses = ["Подано", "Оцінено", "Прийнято", "Відхилено", "На доопрацюванні"];

        // DOM Elements
        const submissionForm = document.getElementById('submissionForm');
        const subTaskIdSelect = document.getElementById('subTaskIdSelect');
        const subUserIdSelect = document.getElementById('subUserIdSelect');
        const submissionTextInput = document.getElementById('submissionText');
        const subStatusSelect = document.getElementById('subStatusSelect');
        const scoreInput = document.getElementById('score');

        const editSubmissionFormContainer = document.getElementById('editSubmissionFormContainer');
        const editSubmissionForm = document.getElementById('editSubmissionForm');
        const editSubIdInput = document.getElementById('editSubId');
        const editSubTaskDisplay = document.getElementById('editSubTaskDisplay');
        const editSubUserDisplay = document.getElementById('editSubUserDisplay');
        const editSubSubmissionTextInput = document.getElementById('editSubSubmissionText');
        const editSubStatusSelect = document.getElementById('editSubStatusSelect');
        const editScoreInput = document.getElementById('editScore');
        const cancelSubEditBtn = document.getElementById('cancelSubEditBtn');

        const submissionsTableBody = document.getElementById('submissionsTableBody');
        const filterSubTaskIdSelect = document.getElementById('filterSubTaskIdSelect');
        const filterSubUserIdSelect = document.getElementById('filterSubUserIdSelect');
        const applySubFilterBtn = document.getElementById('applySubFilterBtn');
        const clearSubFilterBtn = document.getElementById('clearSubFilterBtn');

        function populateLocalSubmissionStatusSelect(selectElement) {
            populateGenericSelect(selectElement, predefinedSubmissionStatuses.map(s => ({ value: s, text: s })), 'value', 'text', 'Виберіть статус...');
        }

        async function initializeDropdownsForSubmissions() {
            await populateSelectWithOptions(subTaskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Виберіть завдання...');
            await populateSelectWithOptions(subUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Виберіть користувача...');
            populateLocalSubmissionStatusSelect(subStatusSelect);

            // Для форми редагування (статуси)
            populateLocalSubmissionStatusSelect(editSubStatusSelect);

            // Для фільтрів
            await populateSelectWithOptions(filterSubTaskIdSelect, tasksApiLookupUrl, 'id', 'description', 'Всі завдання', true);
            await populateSelectWithOptions(filterSubUserIdSelect, usersApiLookupUrl, 'id', 'username', 'Всі користувачі', true);
        }

        async function fetchSubmissions() {
            let url = submissionsApiUrl;
            const params = new URLSearchParams();
            const taskId = filterSubTaskIdSelect.value;
            const userId = filterSubUserIdSelect.value;

            if (taskId) params.append('taskId', taskId); // Використовуємо taskIdParam як на бекенді
            if (userId) params.append('userId', userId); // Використовуємо userIdParam як на бекенді

            const queryString = params.toString();
            if (queryString) url += `?${queryString}`;

            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const submissions = await response.json();
                renderSubmissions(submissions);
            } catch (error) {
                console.error('Помилка завантаження подань:', error);
                showMessage('messageContainer', `Помилка завантаження подань: ${error.message}`, 'error');
                submissionsTableBody.innerHTML = `<tr><td colspan="8">Не вдалося завантажити дані. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderSubmissions(submissions) {
            submissionsTableBody.innerHTML = '';
            if (!submissions || submissions.length === 0) {
                submissionsTableBody.innerHTML = '<tr><td colspan="8" style="text-align:center;">Подання не знайдено.</td></tr>';
                return;
            }
            submissions.forEach(sub => {
                const row = submissionsTableBody.insertRow();
                const submittedAt = sub.submittedAt ? new Date(sub.submittedAt).toLocaleString('uk-UA') : 'N/A';
                const scoreDisplay = sub.score !== null ? sub.score : '';
                row.innerHTML = `
                    <td>${sub.id}</td>
                    <td>${escapeHtml(sub.taskDescription)} (ID: ${sub.taskId})</td>
                    <td>${escapeHtml(sub.username)} (ID: ${sub.userId})</td>
                    <td>${escapeHtml(sub.submission.substring(0,50))}...</td>
                    <td>${escapeHtml(sub.status)}</td>
                    <td>${scoreDisplay}</td>
                    <td>${submittedAt}</td>
                    <td>
                        <button class="edit-btn" data-id="${sub.id}">Оцінити/Статус</button>
                        <button class="delete-btn" data-id="${sub.id}">Видалити</button>
                    </td>
                `;
            });
        }

        submissionForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const taskId = subTaskIdSelect.value;
            const userId = subUserIdSelect.value;
            const submissionText = submissionTextInput.value;
            const status = subStatusSelect.value;
            const scoreStr = scoreInput.value;

            if (!taskId || !userId || !submissionText.trim() || !status) {
                showMessage('messageContainer', 'Завдання, користувач, текст подання та статус є обов\'язковими.', 'error'); return;
            }

            const submissionData = {
                taskId: parseInt(taskId), userId: parseInt(userId),
                submission: submissionText, status: status,
                score: scoreStr ? parseInt(scoreStr) : null
            };

            console.log('Спроба додати подання:', JSON.stringify(submissionData, null, 2));
            try {
                const response = await fetch(submissionsApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(submissionData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Подання успішно додано!', 'success');
                submissionForm.reset();
                subTaskIdSelect.value = ""; subUserIdSelect.value = ""; subStatusSelect.value = "";
                fetchSubmissions();
            } catch (error) {
                console.error('Помилка додавання подання:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        async function populateEditSubmissionForm(id) {
            try {
                const response = await fetch(`${submissionsApiUrl}/${id}`); // Запит на GET /api/TaskSubmissions/{id}
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const sub = await response.json();

                editSubIdInput.value = sub.id;
                editSubTaskDisplay.textContent = `${escapeHtml(sub.taskDescription)} (ID: ${sub.taskId})`;
                editSubUserDisplay.textContent = `${escapeHtml(sub.username)} (ID: ${sub.userId})`;
                editSubSubmissionTextInput.value = sub.submission; // Можна зробити readonly
                editSubStatusSelect.value = sub.status;
                editScoreInput.value = sub.score !== null ? sub.score : '';

                editSubmissionFormContainer.classList.remove('hidden');
                editSubmissionFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
            } catch (error) {
                console.error('Помилка завантаження подання для редагування:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        }

        editSubmissionForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editSubIdInput.value;
            const status = editSubStatusSelect.value;
            const scoreStr = editScoreInput.value;
            // Submission, TaskId, UserId не редагуються через цю форму (згідно з TaskSubmissionUpdateDto)
            // const submissionText = editSubSubmissionTextInput.value;

            if (!status) { showMessage('messageContainer', 'Статус є обов\'язковим.', 'error'); return; }

            const updateData = {
                status: status,
                score: scoreStr ? parseInt(scoreStr) : null
                // submission: submissionText // Якщо дозволяємо оновлення тексту подання
            };
            console.log(`Спроба оновити подання ID ${id}:`, JSON.stringify(updateData, null, 2));
            try {
                const response = await fetch(`${submissionsApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(updateData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Подання успішно оновлено!', 'success');
                editSubmissionFormContainer.classList.add('hidden'); editSubmissionForm.reset();
                fetchSubmissions();
            } catch (error) {
                console.error('Помилка оновлення подання:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelSubEditBtn.addEventListener('click', () => {
            editSubmissionFormContainer.classList.add('hidden'); editSubmissionForm.reset();
        });

        submissionsTableBody.addEventListener('click', async (event) => {
            const target = event.target;
            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Видалити подання ID: ${id}?`)) {
                    try {
                        const response = await fetch(`${submissionsApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Подання успішно видалено!', 'success');
                        fetchSubmissions();
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                const id = target.dataset.id;
                populateEditSubmissionForm(id);
            }
        });

        applySubFilterBtn.addEventListener('click', fetchSubmissions);
        clearSubFilterBtn.addEventListener('click', () => {
            filterSubTaskIdSelect.value = ''; filterSubUserIdSelect.value = '';
            fetchSubmissions();
        });

        async function initializePage() {
            await initializeDropdownsForSubmissions();
            await fetchSubmissions();
        }
        initializePage();
    </script>
</body>
</html>
//
tasksubmissions
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Керування Користувачами</title>
    <link rel="stylesheet" href="../css/site.css">
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo"><a href="/index.html">TaskSystem</a></div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                   
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span>
            </button>
        </div>
    </header>


    <div class="container">
        <h1>Керування Користувачами</h1>
        <div id="messageContainer"></div> <form id="userForm">
            <h3>Додати нового користувача</h3>
            <div>
                <label for="username">Ім'я користувача:</label>
                <input type="text" id="username" name="username" required>
            </div>
            <button type="submit">Додати Користувача</button>
        </form>

        <div id="editUserFormContainer" class="hidden">
            <h3>Редагувати ім'я користувача</h3>
            <form id="editUserForm">
                <input type="hidden" id="editUserId">
                <div>
                    <label for="editUsername">Нове ім'я користувача:</label>
                    <input type="text" id="editUsername" name="username" required>
                </div>
                <button type="submit">Зберегти Ім'я</button>
                <button type="button" id="cancelUserEditBtn" class="cancel-btn">Скасувати</button>
            </form>
        </div>

        <h3>Список Користувачів</h3>
        <div class="filter-container" style="margin-bottom: 1rem;">
            <label for="userSearchInput">Пошук за ім'ям:</label>
            <input type="text" id="userSearchInput" placeholder="Введіть ім'я для пошуку" style="min-width: 200px;">
            <button id="applyUserSearchBtn" type="button" style="margin-left:10px;">Пошук</button>
            <button id="clearUserSearchBtn" type="button" class="cancel-btn">Очистити</button>
        </div>
        <table>
            <thead>
                <tr>
                    <th>ID</th>
                    <th>Ім'я користувача</th>
                    <th>Дії</th>
                </tr>
            </thead>
            <tbody id="usersTableBody"></tbody>
        </table>
    </div>

    <script>
        // --- ПОЧАТОК КОДУ, ЯКИЙ МАВ БУТИ У common.js (ТЕПЕР НА КОЖНІЙ СТОРІНЦІ) ---

        /**
         * Відображає повідомлення для користувача.
         * @param {string} containerId - ID HTML-елемента, де буде відображено повідомлення.
         * @param {string} text - Текст повідомлення.
         * @param {string} type - Тип повідомлення ('success', 'error', 'info').
         */
        function showMessage(containerId, text, type = 'success') {
            const messageContainerEl = document.getElementById(containerId); // Змінив ім'я змінної, щоб не було конфлікту з глобальною messageContainer
            if (!messageContainerEl) {
                console.error(`Message container with id '${containerId}' not found.`);
                return;
            }
            messageContainerEl.innerHTML = '';
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            messageContainerEl.appendChild(messageDiv);
            setTimeout(() => {
                if (messageDiv.parentNode === messageContainerEl) {
                    messageContainerEl.innerHTML = '';
                }
            }, 4000);
        }

        /**
         * Екранує спеціальні HTML-символи для безпечного відображення тексту.
         * @param {string | number | null | undefined} unsafe - Текст для екранування.
         * @returns {string} Екранований текст.
         */
        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') {
                return '';
            }
            return unsafe.toString()
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        /**
         * Обробляє помилкову відповідь від API та повертає текст помилки.
         * @param {Response} response - Об'єкт Response від fetch.
         * @returns {Promise<string>} Текст помилки.
         */
        async function handleApiResponseError(response) {
            let errorMessage = `Помилка ${response.status}: ${response.statusText || 'Невідома помилка сервера'}`;
            try {
                const errorData = await response.json();
                if (errorData) {
                    if (errorData.message) {
                        errorMessage = errorData.message;
                    } else if (errorData.title && errorData.errors) {
                        const errorDetails = Object.values(errorData.errors).flat().join('; ');
                        errorMessage = `${errorData.title}${errorDetails ? ': ' + errorDetails : ''}`;
                    } else if (typeof errorData === 'string' && errorData.length > 0 && errorData.length < 500) {
                        errorMessage = errorData;
                    } else if (response.status === 400 && errorData.errors) {
                        const errorDetails = Object.keys(errorData.errors)
                            .map(key => `${key}: ${errorData.errors[key].join(', ')}`)
                            .join('; ');
                        errorMessage = `Помилка валідації: ${errorDetails}`;
                    }
                }
            } catch (e) {
                const textResponse = await response.text();
                if (textResponse && textResponse.length > 0 && textResponse.length < 500) {
                    errorMessage = textResponse;
                }
                console.warn('Не вдалося розпарсити тіло помилки як JSON:', e);
            }
            return errorMessage;
        }

        // Функції populateGenericSelect та populateSelectWithOptions, якщо вони потрібні на цій сторінці
        // (для users/index.html вони, ймовірно, не потрібні, оскільки немає випадних списків для заповнення з API)
        // Але якщо ти їх десь викликаєш, їх теж треба сюди додати.
        // Я їх поки закоментую, щоб не захаращувати, якщо вони не потрібні саме тут.
        /*
        function populateGenericSelect(selectElement, items, valueField, textField, defaultOptionText, addEmptyOptionAsDefault = true) {
            if (!selectElement) return;
            selectElement.innerHTML = '';
            if (addEmptyOptionAsDefault) {
                const defaultOpt = document.createElement('option');
                defaultOpt.value = "";
                defaultOpt.textContent = defaultOptionText;
                selectElement.appendChild(defaultOpt);
            }
            if (items && Array.isArray(items)) {
                items.forEach(item => {
                    const option = document.createElement('option');
                    option.value = item[valueField];
                    option.textContent = item[textField];
                    selectElement.appendChild(option);
                });
            } else {
                console.warn(`populateGenericSelect: items is not an array or is undefined for selectElement id: ${selectElement.id}`);
            }
        }

        async function populateSelectWithOptions(selectElement, apiUrl, valueField, textField, defaultOptionText, isFilter = false) {
            if (!selectElement) return;
            const initialOptionText = isFilter ? defaultOptionText : "Завантаження...";
            selectElement.innerHTML = `<option value="">${initialOptionText}</option>`;
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) {
                    throw new Error(`Не вдалося завантажити дані (${response.status}) для ${selectElement.id || 'селекта'} з ${apiUrl}`);
                }
                const items = await response.json();
                populateGenericSelect(selectElement, items, valueField, textField, defaultOptionText, true);
            } catch (error) {
                console.error(error.message);
                selectElement.innerHTML = `<option value="">Помилка завантаження</option>`;
            }
        }
        */

        // --- Логіка для мобільної навігації та активного посилання в хедері ---
        // Цей код також має бути тут, якщо ти не використовуєш common.js
        document.addEventListener('DOMContentLoaded', () => {
            const mobileNavToggle = document.querySelector('.mobile-nav-toggle');
            const mainNav = document.querySelector('.main-nav');

            if (mobileNavToggle && mainNav) {
                mobileNavToggle.addEventListener('click', () => {
                    const isExpanded = mobileNavToggle.getAttribute('aria-expanded') === 'true' || false;
                    mobileNavToggle.setAttribute('aria-expanded', !isExpanded);
                    mobileNavToggle.classList.toggle('nav-toggled'); // Для CSS анімації "бургера"
                    mainNav.classList.toggle('active');
                });
            }

            try {
                const currentPath = window.location.pathname;
                const navLinks = document.querySelectorAll('.main-nav a');
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    const linkHref = link.getAttribute('href');
                    if (linkHref) {
                        if (linkHref === currentPath || (linkHref === '/index.html' && currentPath === '/')) {
                            link.classList.add('active');
                        } else if (linkHref !== '/' && linkHref !== '/index.html' && currentPath.startsWith(linkHref.replace(/index\.html$/, ''))) {
                            if (currentPath.startsWith(linkHref) || currentPath.startsWith(linkHref.substring(0, linkHref.lastIndexOf('/') + 1 || linkHref.length))) {
                                link.classList.add('active');
                            }
                        }
                    }
                });
                const activeLink = document.querySelector('.main-nav a.active');
                if (!activeLink && (currentPath === '/' || currentPath === '/index.html')) {
                    const homeLink = document.querySelector('.main-nav a[href="/index.html"], .main-nav a[href="/"]');
                    if (homeLink) homeLink.classList.add('active');
                }
            } catch (e) { console.error("Помилка підсвічування активного посилання:", e); }
        });
        // --- КІНЕЦЬ КОДУ, ЯКИЙ МАВ БУТИ У common.js ---


        // --- JavaScript, специфічний для users/index.html ---
        const usersApiUrl = '/api/Users';

        // DOM Elements (ті, що потрібні тільки тут)
        const userForm = document.getElementById('userForm');
        const usernameInput = document.getElementById('username');
        const editUserFormContainer = document.getElementById('editUserFormContainer');
        const editUserForm = document.getElementById('editUserForm');
        const editUserIdInput = document.getElementById('editUserId');
        const editUsernameInput = document.getElementById('editUsername');
        const cancelUserEditBtn = document.getElementById('cancelUserEditBtn');
        const usersTableBody = document.getElementById('usersTableBody');
        const userSearchInput = document.getElementById('userSearchInput');
        const applyUserSearchBtn = document.getElementById('applyUserSearchBtn');
        const clearUserSearchBtn = document.getElementById('clearUserSearchBtn');
        // Глобальна змінна messageContainer для цієї сторінки (якщо showMessage НЕ приймає ID контейнера)
        const messageContainer = document.getElementById('messageContainer');


        // Функції, специфічні для цієї сторінки
        async function fetchUsers(searchTerm = null) {
            let url = usersApiUrl;
            if (searchTerm && searchTerm.trim() !== '') {
                url += `?search=${encodeURIComponent(searchTerm.trim())}`;
            }
            try {
                const response = await fetch(url);
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                const users = await response.json();
                renderUsers(users);
            } catch (error) {
                console.error('Помилка завантаження користувачів:', error);
                showMessage('messageContainer', `Помилка завантаження користувачів: ${error.message}`, 'error');
                usersTableBody.innerHTML = `<tr><td colspan="3" style="text-align:center;">Не вдалося завантажити дані. ${escapeHtml(error.message)}</td></tr>`;
            }
        }

        function renderUsers(users) {
            usersTableBody.innerHTML = '';
            if (!users || users.length === 0) {
                usersTableBody.innerHTML = '<tr><td colspan="3" style="text-align:center;">Користувачі не знайдені.</td></tr>';
                return;
            }
            users.forEach(user => {
                const row = usersTableBody.insertRow();
                row.innerHTML = `
                            <td>${user.id}</td>
                            <td>${escapeHtml(user.username)}</td>
                            <td>
                                <button class="edit-btn" data-id="${user.id}" data-username="${escapeHtml(user.username)}">Редагувати</button>
                                <button class="delete-btn" data-id="${user.id}">Видалити</button>
                            </td>
                        `;
            });
        }

        userForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const username = usernameInput.value;
            if (!username.trim()) {
                showMessage('messageContainer', "Ім'я користувача не може бути порожнім.", 'error'); return;
            }
            const userData = { username: username };
            console.log('Спроба додати користувача:', JSON.stringify(userData, null, 2));
            try {
                const response = await fetch(usersApiUrl, {
                    method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(userData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', 'Користувача успішно додано!', 'success');
                userForm.reset();
                fetchUsers(userSearchInput.value);
            } catch (error) {
                console.error('Помилка додавання користувача:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        function populateEditUserForm(id, currentUsername) {
            editUserIdInput.value = id;
            editUsernameInput.value = currentUsername;
            editUserFormContainer.classList.remove('hidden');
            editUserFormContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        editUserForm.addEventListener('submit', async (event) => {
            event.preventDefault();
            const id = editUserIdInput.value;
            const username = editUsernameInput.value;
            if (!username.trim()) {
                showMessage('messageContainer', "Нове ім'я користувача не може бути порожнім.", 'error'); return;
            }
            const userData = { username: username };
            console.log(`Спроба оновити користувача ID ${id}:`, JSON.stringify(userData, null, 2));
            try {
                const response = await fetch(`${usersApiUrl}/${id}`, {
                    method: 'PUT', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(userData)
                });
                if (!response.ok) throw new Error(await handleApiResponseError(response));
                showMessage('messageContainer', "Ім'я користувача успішно оновлено!", 'success');
                editUserFormContainer.classList.add('hidden'); editUserForm.reset();
                fetchUsers(userSearchInput.value);
            } catch (error) {
                console.error('Помилка оновлення користувача:', error);
                showMessage('messageContainer', `Помилка: ${error.message}`, 'error');
            }
        });

        cancelUserEditBtn.addEventListener('click', () => {
            editUserFormContainer.classList.add('hidden'); editUserForm.reset();
        });

        usersTableBody.addEventListener('click', async (event) => {
            const target = event.target.closest('button');
            if (!target) return;

            if (target.classList.contains('delete-btn')) {
                const id = target.dataset.id;
                if (confirm(`Видалити користувача ID: ${id}? УВАГА: Це може бути неможливо, якщо користувач пов'язаний з завданнями, групами тощо.`)) {
                    try {
                        const response = await fetch(`${usersApiUrl}/${id}`, { method: 'DELETE' });
                        if (!response.ok) throw new Error(await handleApiResponseError(response));
                        showMessage('messageContainer', 'Користувача успішно видалено!', 'success');
                        fetchUsers(userSearchInput.value);
                    } catch (error) { showMessage('messageContainer', `Помилка: ${error.message}`, 'error'); }
                }
            } else if (target.classList.contains('edit-btn')) {
                populateEditUserForm(target.dataset.id, target.dataset.username);
            }
        });

        applyUserSearchBtn.addEventListener('click', () => fetchUsers(userSearchInput.value));
        clearUserSearchBtn.addEventListener('click', () => {
            userSearchInput.value = ''; fetchUsers();
        });

        async function initializePage() {
            await fetchUsers();
        }

        // Оскільки common.js (якщо б він був) має DOMContentLoaded,
        // а тут ми його не маємо, то краще обгорнути ініціалізацію сторінки,
        // хоча логіка хедера також має DOMContentLoaded.
        // Якщо логіка хедера вже відпрацювала, то можна викликати initializePage напряму.
        // Для безпеки, якщо є сумніви:
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initializePage);
        } else {
            initializePage(); // DOM вже завантажений
        }
        // Або просто:
        // initializePage(); // Якщо логіка хедера (теж у DOMContentLoaded) вже є вище.

    </script>
</body>
</html>
//
index.html
//
<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Головна - TaskSystem</title>
    <link rel="stylesheet" href="/css/site.css">
    <style>
        /* Додаткові стилі для карток на головній сторінці */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); /* Адаптивні колонки */
            gap: 20px;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        .dashboard-card {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
        }

            .dashboard-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 4px 10px rgba(0,0,0,0.15);
            }

            .dashboard-card h3 {
                margin-top: 0;
                color: #2c3e50;
                font-size: 1.5rem;
            }

            .dashboard-card .count {
                font-size: 2.5rem;
                font-weight: bold;
                color: #3498db;
                margin: 10px 0;
                display: block;
            }

            .dashboard-card .card-link {
                display: inline-block;
                margin-top: 15px;
                padding: 10px 20px;
                background-color: #3498db;
                color: white;
                text-decoration: none;
                border-radius: 4px;
                font-weight: 500;
                transition: background-color 0.2s;
            }

                .dashboard-card .card-link:hover {
                    background-color: #2980b9;
                }

        .recent-activity {
            background-color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

            .recent-activity h3 {
                margin-top: 0;
            }

            .recent-activity ul {
                list-style: none;
                padding: 0;
            }

            .recent-activity li {
                padding: 8px 0;
                border-bottom: 1px solid #eee;
            }

                .recent-activity li:last-child {
                    border-bottom: none;
                }

            .recent-activity a {
                text-decoration: none;
                color: #2980b9;
            }

                .recent-activity a:hover {
                    text-decoration: underline;
                }

        .welcome-section {
            text-align: center;
            padding: 20px;
            background-color: #eaf2f8; /* Світлий фон для секції */
            border-radius: 8px;
            margin-bottom: 30px;
        }

            .welcome-section p {
                font-size: 1.1rem;
                color: #5d6d7e;
            }
    </style>
</head>
<body>
    <header>
        <div class="header-container">
            <div class="logo">
                <a href="/index.html">TaskSystem</a>
            </div>
            <nav class="main-nav">
                <ul>
                    <li><a href="/tasks/index.html">Завдання</a></li>
                    <li><a href="/comments/index.html">Коментарі</a></li>
                    <li><a href="/groupmembers/index.html">Члени Груп</a></li>
                    <li><a href="/taskgroups/index.html">Групи Завдань</a></li>
                    <li><a href="/tasksubmissions/index.html">Подання</a></li>
                    <li><a href="/taskattachments/index.html">Вкладення</a></li>
                    <li><a href="/users/index.html">Користувачі</a></li>
                </ul>
            </nav>
            <button class="mobile-nav-toggle" aria-label="Toggle navigation" aria-expanded="false">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
        </div>
    </header>

    <div class="container">
        <div class="welcome-section">
            <h1>Ласкаво просимо до TaskSystem!</h1>
            <p>Ваш надійний помічник для керування завданнями та проєктами.</p>
        </div>

        <div id="messageContainer"></div> <div class="dashboard-grid">
            <div class="dashboard-card">
                <h3>Завдання</h3>
                <span class="count" id="tasksCount">--</span>
                <p>Загальна кількість завдань</p>
                <a href="/tasks/index.html" class="card-link">Керувати Завданнями</a>
            </div>
            <div class="dashboard-card">
                <h3>Користувачі</h3>
                <span class="count" id="usersCount">--</span>
                <p>Зареєстрованих користувачів</p>
                <a href="/users/index.html" class="card-link">Керувати Користувачами</a>
            </div>
            <div class="dashboard-card">
                <h3>Групи Завдань</h3>
                <span class="count" id="taskGroupsCount">--</span>
                <p>Створено груп завдань</p>
                <a href="/taskgroups/index.html" class="card-link">Керувати Групами</a>
            </div>
            <div class="dashboard-card">
                <h3>Швидке Створення</h3>
                <p>Додати нове завдання або групу</p>
                <a href="/tasks/index.html#taskForm" class="card-link" style="margin-right: 10px;">Нове Завдання</a>
                <a href="/taskgroups/index.html#taskGroupForm" class="card-link">Нова Група</a>
            </div>
        </div>

        <div class="recent-activity">
            <h3>Остання активність (Останні завдання)</h3>
            <ul id="recentTasksList">
                <li>Завантаження...</li>
            </ul>
        </div>
    </div>

    <script src="/js/common.js"></script>
    <script>
        // URL-и API для статистики (якщо вони є) або для отримання повних списків
        const tasksApi = '/api/Tasks';
        const usersApi = '/api/Users';
        const taskGroupsApi = '/api/TaskGroups';

        // DOM елементи для статистики
        const tasksCountEl = document.getElementById('tasksCount');
        const usersCountEl = document.getElementById('usersCount');
        const taskGroupsCountEl = document.getElementById('taskGroupsCount');
        const recentTasksListEl = document.getElementById('recentTasksList');

        async function fetchDashboardData() {
            try {
                // Отримання кількості завдань
                const tasksResponse = await fetch(tasksApi);
                if (tasksResponse.ok) {
                    const tasks = await tasksResponse.json();
                    tasksCountEl.textContent = tasks.length; // Простий підрахунок на клієнті

                    // Відображення останніх 5 завдань (сортування за ID desc як проксі для дати)
                    const sortedTasks = tasks.sort((a, b) => b.id - a.id).slice(0, 5);
                    recentTasksListEl.innerHTML = ''; // Очистити "Завантаження..."
                    if (sortedTasks.length > 0) {
                        sortedTasks.forEach(task => {
                            const li = document.createElement('li');
                            // Посилання на сторінку завдання (якщо є окрема сторінка для перегляду одного завдання)
                            // Поки що посилання веде на загальну сторінку завдань
                            li.innerHTML = `<a href="/tasks/index.html#task-${task.id}">${escapeHtml(task.description)}</a> (Статус: ${escapeHtml(task.status)})`;
                            recentTasksListEl.appendChild(li);
                        });
                    } else {
                        recentTasksListEl.innerHTML = '<li>Немає нещодавніх завдань.</li>';
                    }

                } else {
                    tasksCountEl.textContent = 'Помилка';
                    recentTasksListEl.innerHTML = '<li>Помилка завантаження завдань.</li>';
                }
            } catch (error) {
                console.error("Error fetching tasks data:", error);
                tasksCountEl.textContent = 'N/A';
                recentTasksListEl.innerHTML = '<li>Помилка зв\'язку.</li>';
            }

            try {
                // Отримання кількості користувачів
                const usersResponse = await fetch(usersApi);
                if (usersResponse.ok) {
                    const users = await usersResponse.json();
                    usersCountEl.textContent = users.length;
                } else {
                    usersCountEl.textContent = 'Помилка';
                }
            } catch (error) {
                console.error("Error fetching users data:", error);
                usersCountEl.textContent = 'N/A';
            }

            try {
                // Отримання кількості груп завдань
                const taskGroupsResponse = await fetch(taskGroupsApi);
                if (taskGroupsResponse.ok) {
                    const groups = await taskGroupsResponse.json();
                    taskGroupsCountEl.textContent = groups.length;
                } else {
                    taskGroupsCountEl.textContent = 'Помилка';
                }
            } catch (error) {
                console.error("Error fetching task groups data:", error);
                taskGroupsCountEl.textContent = 'N/A';
            }
        }

        // Ініціалізація сторінки
        document.addEventListener('DOMContentLoaded', () => {
            // Логіка для мобільного меню та активного посилання вже має бути в common.js
            // Якщо ні, то її потрібно додати і сюди.

            // Завантаження даних для дашборду
            fetchDashboardData();
        });
    </script>
</body>
</html>
//